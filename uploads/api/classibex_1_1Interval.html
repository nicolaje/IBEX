<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>IBEX: ibex::Interval Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!!
-->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
function scroll(id) {
        var offset = $(id).offset().top; 
	$('html,body', window.parent.document).animate({scrollTop: offset}, 'fast');
}
</script>
</head>
<body>
<div id="top" style="background-image: url(../NCleanBlue/ibexbg960.png) no-repeat right;"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibex</b></li><li class="navelem"><a class="el" href="classibex_1_1Interval.html">Interval</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classibex_1_1Interval.html#pub-methods">Public Member Functions</a> &#124;
<a href="classibex_1_1Interval.html#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classibex_1_1Interval-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibex::Interval Class Reference<div class="ingroups"><a class="el" href="group__arithmetic.html">Interval Arithmetic</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>.  
 <a href="classibex_1_1Interval.html#details">More...</a></p>

<p><code>#include &lt;ibex_Interval.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e725acfe31355ab02d0e6586149f020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e725acfe31355ab02d0e6586149f020"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a1e725acfe31355ab02d0e6586149f020">Interval</a> ()</td></tr>
<tr class="memdesc:a1e725acfe31355ab02d0e6586149f020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (-oo,+oo). <br/></td></tr>
<tr class="separator:a1e725acfe31355ab02d0e6586149f020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d42efc62e18fe162751cb7ddeafe68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54d42efc62e18fe162751cb7ddeafe68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a54d42efc62e18fe162751cb7ddeafe68">Interval</a> (double a, double b)</td></tr>
<tr class="memdesc:a54d42efc62e18fe162751cb7ddeafe68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [a,b]. <br/></td></tr>
<tr class="separator:a54d42efc62e18fe162751cb7ddeafe68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c28ef3a150220d3ccedbd9c74c14a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a105c28ef3a150220d3ccedbd9c74c14a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a105c28ef3a150220d3ccedbd9c74c14a">Interval</a> (double a)</td></tr>
<tr class="memdesc:a105c28ef3a150220d3ccedbd9c74c14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [a,a]. <br/></td></tr>
<tr class="separator:a105c28ef3a150220d3ccedbd9c74c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dffd53a239f0a25b975b109f6b9aa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6dffd53a239f0a25b975b109f6b9aa9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aa6dffd53a239f0a25b975b109f6b9aa9">operator==</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:aa6dffd53a239f0a25b975b109f6b9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are exactly the same intervals. <br/></td></tr>
<tr class="separator:aa6dffd53a239f0a25b975b109f6b9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22c0d0b59162e93682cf5a62a3bd521"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22c0d0b59162e93682cf5a62a3bd521"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ad22c0d0b59162e93682cf5a62a3bd521">operator!=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:ad22c0d0b59162e93682cf5a62a3bd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are not exactly the same intervals. <br/></td></tr>
<tr class="separator:ad22c0d0b59162e93682cf5a62a3bd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1d37967c0758350890df1ba6122fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a1d37967c0758350890df1ba6122fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ae9a1d37967c0758350890df1ba6122fb">set_empty</a> ()</td></tr>
<tr class="memdesc:ae9a1d37967c0758350890df1ba6122fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this interval to the empty set. <br/></td></tr>
<tr class="separator:ae9a1d37967c0758350890df1ba6122fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e6fb04dc461baf868dd42152baae2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79e6fb04dc461baf868dd42152baae2d"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a79e6fb04dc461baf868dd42152baae2d">operator=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a79e6fb04dc461baf868dd42152baae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to x. <br/></td></tr>
<tr class="separator:a79e6fb04dc461baf868dd42152baae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bfe433afab604a273ce97d1857b936"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15bfe433afab604a273ce97d1857b936"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a15bfe433afab604a273ce97d1857b936">operator=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a15bfe433afab604a273ce97d1857b936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to x. <br/></td></tr>
<tr class="separator:a15bfe433afab604a273ce97d1857b936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa161c2e40d7136766367721fbcd794b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa161c2e40d7136766367721fbcd794b"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aaa161c2e40d7136766367721fbcd794b">operator=</a> (double x)</td></tr>
<tr class="memdesc:aaa161c2e40d7136766367721fbcd794b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to d. <br/></td></tr>
<tr class="separator:aaa161c2e40d7136766367721fbcd794b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb9db01ceb66620e4ab22b004386d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a3fb9db01ceb66620e4ab22b004386d3a">operator&amp;=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a3fb9db01ceb66620e4ab22b004386d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of *this and x.  <a href="classibex_1_1Interval.html#a3fb9db01ceb66620e4ab22b004386d3a">More...</a><br/></td></tr>
<tr class="separator:a3fb9db01ceb66620e4ab22b004386d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9266e4411200dbd296f686fa622454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a3f9266e4411200dbd296f686fa622454">operator&amp;=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a3f9266e4411200dbd296f686fa622454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of *this and x.  <a href="classibex_1_1Interval.html#a3f9266e4411200dbd296f686fa622454">More...</a><br/></td></tr>
<tr class="separator:a3f9266e4411200dbd296f686fa622454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46afba5aa75af34eb792fe65199ec93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ac46afba5aa75af34eb792fe65199ec93">operator|=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:ac46afba5aa75af34eb792fe65199ec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of *this and x.  <a href="classibex_1_1Interval.html#ac46afba5aa75af34eb792fe65199ec93">More...</a><br/></td></tr>
<tr class="separator:ac46afba5aa75af34eb792fe65199ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b04c5c67910f955df026a751e2fb2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a71b04c5c67910f955df026a751e2fb2b">operator|=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a71b04c5c67910f955df026a751e2fb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of *this and x.  <a href="classibex_1_1Interval.html#a71b04c5c67910f955df026a751e2fb2b">More...</a><br/></td></tr>
<tr class="separator:a71b04c5c67910f955df026a751e2fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f38ca5dd0e71971c8e57bc90ff3b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a98f38ca5dd0e71971c8e57bc90ff3b3a">inflate</a> (double <a class="el" href="classibex_1_1Interval.html#a2589395d19aabef3d1ed2094e43b8da4">rad</a>)</td></tr>
<tr class="memdesc:a98f38ca5dd0e71971c8e57bc90ff3b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add [-rad,+rad] to *this.  <a href="classibex_1_1Interval.html#a98f38ca5dd0e71971c8e57bc90ff3b3a">More...</a><br/></td></tr>
<tr class="separator:a98f38ca5dd0e71971c8e57bc90ff3b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d81d192fd4562602837dfad3677090"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#af4d81d192fd4562602837dfad3677090">lb</a> () const </td></tr>
<tr class="memdesc:af4d81d192fd4562602837dfad3677090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower bound.  <a href="classibex_1_1Interval.html#af4d81d192fd4562602837dfad3677090">More...</a><br/></td></tr>
<tr class="separator:af4d81d192fd4562602837dfad3677090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e2ffdabc62fffc39e887c271a2573b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a24e2ffdabc62fffc39e887c271a2573b">ub</a> () const </td></tr>
<tr class="memdesc:a24e2ffdabc62fffc39e887c271a2573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bound.  <a href="classibex_1_1Interval.html#a24e2ffdabc62fffc39e887c271a2573b">More...</a><br/></td></tr>
<tr class="separator:a24e2ffdabc62fffc39e887c271a2573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98ed63f2198c593e12a30922b490b07"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aa98ed63f2198c593e12a30922b490b07">mid</a> () const </td></tr>
<tr class="memdesc:aa98ed63f2198c593e12a30922b490b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Midpoint.  <a href="classibex_1_1Interval.html#aa98ed63f2198c593e12a30922b490b07">More...</a><br/></td></tr>
<tr class="separator:aa98ed63f2198c593e12a30922b490b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589395d19aabef3d1ed2094e43b8da4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a2589395d19aabef3d1ed2094e43b8da4">rad</a> () const </td></tr>
<tr class="memdesc:a2589395d19aabef3d1ed2094e43b8da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius.  <a href="classibex_1_1Interval.html#a2589395d19aabef3d1ed2094e43b8da4">More...</a><br/></td></tr>
<tr class="separator:a2589395d19aabef3d1ed2094e43b8da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf65e5d51a8b43b2bf45070b4227e8b6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#abf65e5d51a8b43b2bf45070b4227e8b6">diam</a> () const </td></tr>
<tr class="memdesc:abf65e5d51a8b43b2bf45070b4227e8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diameter.  <a href="classibex_1_1Interval.html#abf65e5d51a8b43b2bf45070b4227e8b6">More...</a><br/></td></tr>
<tr class="separator:abf65e5d51a8b43b2bf45070b4227e8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f647c5d5b316669b91788d5f924ae6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a3f647c5d5b316669b91788d5f924ae6b">mig</a> () const </td></tr>
<tr class="memdesc:a3f647c5d5b316669b91788d5f924ae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mignitude.  <a href="classibex_1_1Interval.html#a3f647c5d5b316669b91788d5f924ae6b">More...</a><br/></td></tr>
<tr class="separator:a3f647c5d5b316669b91788d5f924ae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9937a500e956b12782cd66e3f428f47"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aa9937a500e956b12782cd66e3f428f47">mag</a> () const </td></tr>
<tr class="memdesc:aa9937a500e956b12782cd66e3f428f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnitude.  <a href="classibex_1_1Interval.html#aa9937a500e956b12782cd66e3f428f47">More...</a><br/></td></tr>
<tr class="separator:aa9937a500e956b12782cd66e3f428f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9138d2d5cb7c3ee8a6a34605f44bcaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ab9138d2d5cb7c3ee8a6a34605f44bcaa">is_subset</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:ab9138d2d5cb7c3ee8a6a34605f44bcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval is a subset of <em>x</em>.  <a href="classibex_1_1Interval.html#ab9138d2d5cb7c3ee8a6a34605f44bcaa">More...</a><br/></td></tr>
<tr class="separator:ab9138d2d5cb7c3ee8a6a34605f44bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ee2d643bd42794bcdca365284cff38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ab6ee2d643bd42794bcdca365284cff38">is_strict_subset</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:ab6ee2d643bd42794bcdca365284cff38"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval is in the interior of <em>x</em>.  <a href="classibex_1_1Interval.html#ab6ee2d643bd42794bcdca365284cff38">More...</a><br/></td></tr>
<tr class="separator:ab6ee2d643bd42794bcdca365284cff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92190f8eaf229278239cbff705a5618b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a92190f8eaf229278239cbff705a5618b">is_superset</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:a92190f8eaf229278239cbff705a5618b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval is a superset of <em>x</em>.  <a href="classibex_1_1Interval.html#a92190f8eaf229278239cbff705a5618b">More...</a><br/></td></tr>
<tr class="separator:a92190f8eaf229278239cbff705a5618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c460c9d128f07b298d222f1a8719792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a0c460c9d128f07b298d222f1a8719792">is_strict_superset</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:a0c460c9d128f07b298d222f1a8719792"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff the interior of *this is a superset of <em>x</em>.  <a href="classibex_1_1Interval.html#a0c460c9d128f07b298d222f1a8719792">More...</a><br/></td></tr>
<tr class="separator:a0c460c9d128f07b298d222f1a8719792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda5f9522a19322e794459d44b838bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#abda5f9522a19322e794459d44b838bb5">contains</a> (double d) const </td></tr>
<tr class="memdesc:abda5f9522a19322e794459d44b838bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this contains <em>d</em>.  <a href="classibex_1_1Interval.html#abda5f9522a19322e794459d44b838bb5">More...</a><br/></td></tr>
<tr class="separator:abda5f9522a19322e794459d44b838bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b524cc5a622314b284cfbb26b5a5f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a2b524cc5a622314b284cfbb26b5a5f1d">strictly_contains</a> (double d) const </td></tr>
<tr class="memdesc:a2b524cc5a622314b284cfbb26b5a5f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff the interior of *this contains <em>d</em>.  <a href="classibex_1_1Interval.html#a2b524cc5a622314b284cfbb26b5a5f1d">More...</a><br/></td></tr>
<tr class="separator:a2b524cc5a622314b284cfbb26b5a5f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac468425f185085464be3d461f0677303"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac468425f185085464be3d461f0677303"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ac468425f185085464be3d461f0677303">is_disjoint</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:ac468425f185085464be3d461f0677303"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and <em>x</em> do not intersect. <br/></td></tr>
<tr class="separator:ac468425f185085464be3d461f0677303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1da096ea3093f39360f2ae88e3652c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1da096ea3093f39360f2ae88e3652c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ac1da096ea3093f39360f2ae88e3652c5">is_empty</a> () const </td></tr>
<tr class="memdesc:ac1da096ea3093f39360f2ae88e3652c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this is empty. <br/></td></tr>
<tr class="separator:ac1da096ea3093f39360f2ae88e3652c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba18a01dc16aa8508fce57a36bff7e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a6ba18a01dc16aa8508fce57a36bff7e3">is_degenerated</a> () const </td></tr>
<tr class="memdesc:a6ba18a01dc16aa8508fce57a36bff7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this is degenerated.  <a href="classibex_1_1Interval.html#a6ba18a01dc16aa8508fce57a36bff7e3">More...</a><br/></td></tr>
<tr class="separator:a6ba18a01dc16aa8508fce57a36bff7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0578857682c0b66a0f3caf60d1fde893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a0578857682c0b66a0f3caf60d1fde893">is_unbounded</a> () const </td></tr>
<tr class="memdesc:a0578857682c0b66a0f3caf60d1fde893"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if one bound of *this is infinite.  <a href="classibex_1_1Interval.html#a0578857682c0b66a0f3caf60d1fde893">More...</a><br/></td></tr>
<tr class="separator:a0578857682c0b66a0f3caf60d1fde893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe49b5e7755710b35ed39fe1705f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a5fe49b5e7755710b35ed39fe1705f2cc">is_bisectable</a> () const </td></tr>
<tr class="memdesc:a5fe49b5e7755710b35ed39fe1705f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this can be bisected into two non-degenerated intervals.  <a href="classibex_1_1Interval.html#a5fe49b5e7755710b35ed39fe1705f2cc">More...</a><br/></td></tr>
<tr class="separator:a5fe49b5e7755710b35ed39fe1705f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dd2ae96f2a1aaf629b6c314a274f4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#af3dd2ae96f2a1aaf629b6c314a274f4f">rel_distance</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:af3dd2ae96f2a1aaf629b6c314a274f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative Hausdorff distance between *this and x.  <a href="classibex_1_1Interval.html#af3dd2ae96f2a1aaf629b6c314a274f4f">More...</a><br/></td></tr>
<tr class="separator:af3dd2ae96f2a1aaf629b6c314a274f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa024c9240f6d3cc524f6478377553a4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa024c9240f6d3cc524f6478377553a4d"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aa024c9240f6d3cc524f6478377553a4d">operator-</a> () const </td></tr>
<tr class="memdesc:aa024c9240f6d3cc524f6478377553a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> -*this. <br/></td></tr>
<tr class="separator:aa024c9240f6d3cc524f6478377553a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb579c2b6279f6b45d0d93c9a9e52b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb579c2b6279f6b45d0d93c9a9e52b8"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a6cb579c2b6279f6b45d0d93c9a9e52b8">operator+=</a> (double d)</td></tr>
<tr class="memdesc:a6cb579c2b6279f6b45d0d93c9a9e52b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>d</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a6cb579c2b6279f6b45d0d93c9a9e52b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0668f05a0ff6f1d275159b863d08beb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0668f05a0ff6f1d275159b863d08beb9"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a0668f05a0ff6f1d275159b863d08beb9">operator-=</a> (double d)</td></tr>
<tr class="memdesc:a0668f05a0ff6f1d275159b863d08beb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <em>d</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a0668f05a0ff6f1d275159b863d08beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63451752f9d88f7c478fe5d80d7bfb81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63451752f9d88f7c478fe5d80d7bfb81"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a63451752f9d88f7c478fe5d80d7bfb81">operator*=</a> (double d)</td></tr>
<tr class="memdesc:a63451752f9d88f7c478fe5d80d7bfb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply *this by <em>d</em> and return the result. <br/></td></tr>
<tr class="separator:a63451752f9d88f7c478fe5d80d7bfb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d70c7f40142bf826d3191e7eb9b430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d70c7f40142bf826d3191e7eb9b430"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a42d70c7f40142bf826d3191e7eb9b430">operator/=</a> (double d)</td></tr>
<tr class="memdesc:a42d70c7f40142bf826d3191e7eb9b430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide *this by <em>d</em> and return the result. <br/></td></tr>
<tr class="separator:a42d70c7f40142bf826d3191e7eb9b430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01f6d6c03a973d06bc13ebdb24130bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01f6d6c03a973d06bc13ebdb24130bc"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ac01f6d6c03a973d06bc13ebdb24130bc">operator+=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:ac01f6d6c03a973d06bc13ebdb24130bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:ac01f6d6c03a973d06bc13ebdb24130bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0013c0c85aacad885ac9fca1981d9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f0013c0c85aacad885ac9fca1981d9b"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a9f0013c0c85aacad885ac9fca1981d9b">operator-=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a9f0013c0c85aacad885ac9fca1981d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a9f0013c0c85aacad885ac9fca1981d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe16792d7a42dec8c7f04a144230e97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fe16792d7a42dec8c7f04a144230e97"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a4fe16792d7a42dec8c7f04a144230e97">operator*=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a4fe16792d7a42dec8c7f04a144230e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply *this by <em>x</em> and return the result. <br/></td></tr>
<tr class="separator:a4fe16792d7a42dec8c7f04a144230e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9833889ffde1be86b23373fe13513f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#afc9833889ffde1be86b23373fe13513f">operator/=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:afc9833889ffde1be86b23373fe13513f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide *this by <em>x</em> and return the result.  <a href="classibex_1_1Interval.html#afc9833889ffde1be86b23373fe13513f">More...</a><br/></td></tr>
<tr class="separator:afc9833889ffde1be86b23373fe13513f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82837757a6b393346ef38d47c2477ad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a82837757a6b393346ef38d47c2477ad5">div2_inter</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x, const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;y, <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;out2)</td></tr>
<tr class="memdesc:a82837757a6b393346ef38d47c2477ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this interval to the intersection of itself with the division of two others.  <a href="classibex_1_1Interval.html#a82837757a6b393346ef38d47c2477ad5">More...</a><br/></td></tr>
<tr class="separator:a82837757a6b393346ef38d47c2477ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e86d43d1a4d3b2d695c498064870a99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e86d43d1a4d3b2d695c498064870a99"></a>
<a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a4e86d43d1a4d3b2d695c498064870a99">div2_inter</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x, const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;y)</td></tr>
<tr class="memdesc:a4e86d43d1a4d3b2d695c498064870a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this interval to the intersection of itself with the division of two others. <br/></td></tr>
<tr class="separator:a4e86d43d1a4d3b2d695c498064870a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5507819af5fa6b2baab2cce5a0d9cc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#aa5507819af5fa6b2baab2cce5a0d9cc1">delta</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:aa5507819af5fa6b2baab2cce5a0d9cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> diam(*this)-diam(x), for x *this [deprecated].  <a href="classibex_1_1Interval.html#aa5507819af5fa6b2baab2cce5a0d9cc1">More...</a><br/></td></tr>
<tr class="separator:aa5507819af5fa6b2baab2cce5a0d9cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e0c17562940e1b3486e0679bb00579"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a03e0c17562940e1b3486e0679bb00579">ratiodelta</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:a03e0c17562940e1b3486e0679bb00579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ratio of the diameter to #delta(x) [deprecated].  <a href="classibex_1_1Interval.html#a03e0c17562940e1b3486e0679bb00579">More...</a><br/></td></tr>
<tr class="separator:a03e0c17562940e1b3486e0679bb00579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95368d7ed26c2ff3972dd502276412"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classibex_1_1Interval.html">Interval</a>, <a class="el" href="classibex_1_1Interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a6f95368d7ed26c2ff3972dd502276412">bisect</a> (double ratio=0.5) const </td></tr>
<tr class="memdesc:a6f95368d7ed26c2ff3972dd502276412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect *this into two subintervals.  <a href="classibex_1_1Interval.html#a6f95368d7ed26c2ff3972dd502276412">More...</a><br/></td></tr>
<tr class="separator:a6f95368d7ed26c2ff3972dd502276412"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af7ffd74212a6493d4beba6710cfd75ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7ffd74212a6493d4beba6710cfd75ee"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#af7ffd74212a6493d4beba6710cfd75ee">PI</a></td></tr>
<tr class="memdesc:af7ffd74212a6493d4beba6710cfd75ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">pi. <br/></td></tr>
<tr class="separator:af7ffd74212a6493d4beba6710cfd75ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d9fa6552a5ade546893dd6f139b2a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3d9fa6552a5ade546893dd6f139b2a1"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ae3d9fa6552a5ade546893dd6f139b2a1">TWO_PI</a></td></tr>
<tr class="memdesc:ae3d9fa6552a5ade546893dd6f139b2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2*pi. <br/></td></tr>
<tr class="separator:ae3d9fa6552a5ade546893dd6f139b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e82062d228408853f39f18ef58ab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace0e82062d228408853f39f18ef58ab3"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ace0e82062d228408853f39f18ef58ab3">HALF_PI</a></td></tr>
<tr class="memdesc:ace0e82062d228408853f39f18ef58ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">pi/2. <br/></td></tr>
<tr class="separator:ace0e82062d228408853f39f18ef58ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a525b148205b83c230c839236dcac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a525b148205b83c230c839236dcac6"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a20a525b148205b83c230c839236dcac6">EMPTY_SET</a></td></tr>
<tr class="memdesc:a20a525b148205b83c230c839236dcac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the empty interval. <br/></td></tr>
<tr class="separator:a20a525b148205b83c230c839236dcac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a20d42dc623ea2c0288bd21035a2a76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a20d42dc623ea2c0288bd21035a2a76"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a5a20d42dc623ea2c0288bd21035a2a76">ALL_REALS</a></td></tr>
<tr class="memdesc:a5a20d42dc623ea2c0288bd21035a2a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">(-oo,oo). <br/></td></tr>
<tr class="separator:a5a20d42dc623ea2c0288bd21035a2a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10ce4d205c17ec0224cb1c10475f0d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab10ce4d205c17ec0224cb1c10475f0d5"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ab10ce4d205c17ec0224cb1c10475f0d5">ZERO</a></td></tr>
<tr class="memdesc:ab10ce4d205c17ec0224cb1c10475f0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">[0,0]. <br/></td></tr>
<tr class="separator:ab10ce4d205c17ec0224cb1c10475f0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd0e6fd8cfc978b827c827e621e82f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9cd0e6fd8cfc978b827c827e621e82f"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#ab9cd0e6fd8cfc978b827c827e621e82f">ONE</a></td></tr>
<tr class="memdesc:ab9cd0e6fd8cfc978b827c827e621e82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[1,1]. <br/></td></tr>
<tr class="separator:ab9cd0e6fd8cfc978b827c827e621e82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f62636ab9e432b51994452d58452bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f62636ab9e432b51994452d58452bf5"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a4f62636ab9e432b51994452d58452bf5">POS_REALS</a></td></tr>
<tr class="memdesc:a4f62636ab9e432b51994452d58452bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">[0,+oo). <br/></td></tr>
<tr class="separator:a4f62636ab9e432b51994452d58452bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea43b3d184aee15b674422149027575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea43b3d184aee15b674422149027575"></a>
static const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Interval.html#a7ea43b3d184aee15b674422149027575">NEG_REALS</a></td></tr>
<tr class="memdesc:a7ea43b3d184aee15b674422149027575"><td class="mdescLeft">&#160;</td><td class="mdescRight">(-oo,0]. <br/></td></tr>
<tr class="separator:a7ea43b3d184aee15b674422149027575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>. </p>
<p>This class defines the interval interface of IBEX and encapsulates an interval "itv" whose type depends on the chosen implementation (currently: Gaol, Bias of filib).</p>
<p>Note that some functions of the Gaol interval interface do not appear here (like "possibly relations") because there are not used by ibex; while other have been introduced (like "ratio_delta"). Some functions are also renamed to match more conventional use.</p>
<p>Note that with filib several precision and mode are available. We choose : base type = double rounding_strategy = native_switched interval_mode = i_mode_extended_flag </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3fb9db01ceb66620e4ab22b004386d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a>&amp; ibex::Interval::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection of *this and x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the interval to compute the intersection with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f9266e4411200dbd296f686fa622454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp; ibex::Interval::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection of *this and x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the affine form to compute the intersection with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac46afba5aa75af34eb792fe65199ec93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a>&amp; ibex::Interval::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of *this and x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the interval to compute the hull with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71b04c5c67910f955df026a751e2fb2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp; ibex::Interval::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union of *this and x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the affine form to compute the hull with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98f38ca5dd0e71971c8e57bc90ff3b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp; ibex::Interval::inflate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add [-rad,+rad] to *this. </p>
<p><a class="el" href="classibex_1_1Return.html">Return</a> a reference to *this. </p>

</div>
</div>
<a class="anchor" id="af4d81d192fd4562602837dfad3677090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::lb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower bound. </p>
<p><a class="el" href="classibex_1_1Return.html">Return</a> the lower bound of *this. </p>

</div>
</div>
<a class="anchor" id="a24e2ffdabc62fffc39e887c271a2573b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::ub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper bound. </p>
<p><a class="el" href="classibex_1_1Return.html">Return</a> the upper bound of *this. </p>

</div>
</div>
<a class="anchor" id="aa98ed63f2198c593e12a30922b490b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::mid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Midpoint. </p>
<p>Returns the midpoint of *this. The return point is guaranteed to be included in *this but not necessarily to be the closest floating point from the real midpoint.</p>
<p>Cases are:</p>
<ul>
<li>-&gt; Quiet NaN</li>
<li>[-oo, +oo] -&gt; midP = 0.0</li>
<li>[-oo, b] -&gt; midP = -MAXREAL</li>
<li>[a, +oo] -&gt; midP = MAXREAL</li>
<li>[a, b] -&gt; midP ~ a + .5*(b-a) </li>
</ul>

</div>
</div>
<a class="anchor" id="a2589395d19aabef3d1ed2094e43b8da4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::rad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Radius. </p>
<p><a class="el" href="classibex_1_1Return.html">Return</a> the diameter of *this. By convention, 0 if *this is empty. </p>

</div>
</div>
<a class="anchor" id="abf65e5d51a8b43b2bf45070b4227e8b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::diam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diameter. </p>
<p><a class="el" href="classibex_1_1Return.html">Return</a> the diameter of *this. By convention, 0 if *this is empty. </p>

</div>
</div>
<a class="anchor" id="a3f647c5d5b316669b91788d5f924ae6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::mig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mignitude. </p>
<p>Returns the mignitude of *this: &lt;lu&gt;  +(lower bound) if *this &gt; 0  -(upper bound) if *this &lt; 0  0 otherwise. &lt;/lu&gt; </p>

</div>
</div>
<a class="anchor" id="aa9937a500e956b12782cd66e3f428f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::mag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magnitude. </p>
<p>Returns the magnitude of *this: mag(*this)=max(|lower bound|, |upper bound|). </p>

</div>
</div>
<a class="anchor" id="ab9138d2d5cb7c3ee8a6a34605f44bcaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_subset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff this interval is a subset of <em>x</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Always return true if *this is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ee2d643bd42794bcdca365284cff38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_strict_subset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True iff this interval is in the interior of <em>x</em>. </p>
<dl class="section note"><dt>Note</dt><dd>In particular, (-oo,oo) is a strict subset of (-oo,oo) and the empty set is a strict subset of the empty set. </dd>
<dd>
Always return true if *this is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a92190f8eaf229278239cbff705a5618b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_superset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff this interval is a superset of <em>x</em>. </p>
<dl class="section note"><dt>Note</dt><dd>Always return true if x is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c460c9d128f07b298d222f1a8719792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_strict_superset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True iff the interior of *this is a superset of <em>x</em>. </p>
<dl class="section note"><dt>Note</dt><dd>In particular, (-oo,oo) is a strict superset of (-oo,oo) </dd></dl>

</div>
</div>
<a class="anchor" id="abda5f9522a19322e794459d44b838bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::contains </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff *this contains <em>d</em>. </p>
<dl class="section note"><dt>Note</dt><dd>d can also be an "open bound", i.e., infinity. So this function is not restricted to a set-membership interpretation. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b524cc5a622314b284cfbb26b5a5f1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::strictly_contains </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff the interior of *this contains <em>d</em>. </p>
<dl class="section note"><dt>Note</dt><dd>d can also be an "open bound", i.e., infinity. So this function is not restricted to a set-membership interpretation. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ba18a01dc16aa8508fce57a36bff7e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_degenerated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff *this is degenerated. </p>
<p>An interval is degenerated if it is of the form [a, a]</p>
<dl class="section note"><dt>Note</dt><dd>An empty interval is considered here as degenerated. </dd></dl>

</div>
</div>
<a class="anchor" id="a0578857682c0b66a0f3caf60d1fde893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_unbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if one bound of *this is infinite. </p>
<dl class="section note"><dt>Note</dt><dd>An empty interval is always bounded. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fe49b5e7755710b35ed39fe1705f2cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::is_bisectable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True iff *this can be bisected into two non-degenerated intervals. </p>
<p>Examples of non bisectable intervals are [0,next_float(0)] or [DBL_MAX,+oo). </p>

</div>
</div>
<a class="anchor" id="af3dd2ae96f2a1aaf629b6c314a274f4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::rel_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative Hausdorff distance between *this and x. </p>
<p>The relative distance is basically distance(x)/diam(*this). </p>
<dl class="section see"><dt>See Also</dt><dd>#ibex::distance (const <a class="el" href="classibex_1_1Interval.html" title="Interval.">ibex::Interval</a> &amp;x1, const <a class="el" href="classibex_1_1Interval.html" title="Interval.">ibex::Interval</a> &amp;x2). </dd></dl>

</div>
</div>
<a class="anchor" id="afc9833889ffde1be86b23373fe13513f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a>&amp; ibex::Interval::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide *this by <em>x</em> and return the result. </p>
<p>Does better than *this=*this/x: because calculates the union of *this/x as intermediate result. </p>

</div>
</div>
<a class="anchor" id="a82837757a6b393346ef38d47c2477ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Interval::div2_inter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>out2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this interval to the intersection of itself with the division of two others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the numerator </td></tr>
    <tr><td class="paramname">y</td><td>- the divisor </td></tr>
    <tr><td class="paramname">out2</td><td>- In return, *this and out2 contains the lower and upper part respectively of the division. If the result of the generalized division and intersection is a single interval, out2 is set to the empty interval. <div class="fragment"><div class="line"><a class="code" href="classibex_1_1Interval.html#a1e725acfe31355ab02d0e6586149f020" title="Create (-oo,+oo).">Interval</a> intv(-10,10);</div>
<div class="line"><a class="code" href="classibex_1_1Interval.html#a1e725acfe31355ab02d0e6586149f020" title="Create (-oo,+oo).">Interval</a> out2;</div>
<div class="line">intv.div2_inter(<a class="code" href="classibex_1_1Interval.html#a1e725acfe31355ab02d0e6586149f020" title="Create (-oo,+oo).">Interval</a>(2,3), <a class="code" href="classibex_1_1Interval.html#a1e725acfe31355ab02d0e6586149f020" title="Create (-oo,+oo).">Interval</a>(-1,2), out2);</div>
<div class="line">cout &lt;&lt; intv &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; out2 &lt;&lt; endl;  <span class="comment">// will display: [-10,-2] [1,10]</span></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the intersection is non empty. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Contrary to the "cset" theory, the result is empty if <em>y=</em>[0,0] (whatever <em>x</em> is). </dd></dl>

</div>
</div>
<a class="anchor" id="aa5507819af5fa6b2baab2cce5a0d9cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::delta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> diam(*this)-diam(x), for x *this [deprecated]. </p>
<p>Deprecated. Kept for compatibility with ibex 1.xx.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>x</em> must be included in this interval. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result may be +oo (if the set difference is infinite). </dd>
<dd>
An empty interval is considered here to have a null diamater (as a degenerated interval). <br/>
 If either <em>x</em> or this interval is empty, then the method returns the diameter of this interval (which is 0 if the latter is empty). </dd></dl>

</div>
</div>
<a class="anchor" id="a03e0c17562940e1b3486e0679bb00579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::Interval::ratiodelta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the ratio of the diameter to #delta(x) [deprecated]. </p>
<p>Deprecated. Kept for compatibility with ibex 1.xx.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>x</em> must be included in this interval. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An empty interval is considered to have a null diamater (as a degenerated interval). <br/>
 <ul>
<li>
If either <em>x</em> or this interval is empty, then <ul>
<li>
the method returns 1 (100% of reduction) if this diameter is not null, </li>
<li>
0 otherwise (as if 0/0=0).</li>
</ul>
</li>
<li>
As a pure convention, the method returns <code>1</code> if one bound of this interval is infinite and the corresponding bound of <em>x</em> is not (in particular if this interval is unbounded and <em>x</em> not). </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6f95368d7ed26c2ff3972dd502276412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classibex_1_1Interval.html">Interval</a>,<a class="el" href="classibex_1_1Interval.html">Interval</a>&gt; ibex::Interval::bisect </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>0.5</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bisect *this into two subintervals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ratio</td><td>- says where to split (0.5=middle) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classibex_1_1Interval.html#a5fe49b5e7755710b35ed39fe1705f2cc" title="True iff *this can be bisected into two non-degenerated intervals.">is_bisectable()</a> must be true. </dd>
<dd>
0&lt;ratio&lt;1. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ibex/ibex_Interval.h</li>
<li>include/ibex/ibex_Affine2.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 26 2013 10:27:36 for IBEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

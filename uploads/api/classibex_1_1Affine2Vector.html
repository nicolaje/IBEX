<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>IBEX: ibex::Affine2Vector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!!
-->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
function scroll(id) {
        var offset = $(id).offset().top; 
	$('html,body', window.parent.document).animate({scrollTop: offset}, 'fast');
}
</script>
</head>
<body>
<div id="top" style="background-image: url(../NCleanBlue/ibexbg960.png) no-repeat right;"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibex</b></li><li class="navelem"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classibex_1_1Affine2Vector.html#pub-methods">Public Member Functions</a> &#124;
<a href="classibex_1_1Affine2Vector.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classibex_1_1Affine2Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibex::Affine2Vector Class Reference<div class="ingroups"><a class="el" href="group__arithmetic.html">Interval Arithmetic</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classibex_1_1Vector.html" title="Vector of reals.">Vector</a> of <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form.  
 <a href="classibex_1_1Affine2Vector.html#details">More...</a></p>

<p><code>#include &lt;ibex_Affine2Vector.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67a1b632f9f166ae95a94f161d75f869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a67a1b632f9f166ae95a94f161d75f869">Affine2Vector</a> (int n)</td></tr>
<tr class="memdesc:a67a1b632f9f166ae95a94f161d75f869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>n</em> <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form . All the components are <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>([-oo,+oo])  <a href="classibex_1_1Affine2Vector.html#a67a1b632f9f166ae95a94f161d75f869">More...</a><br/></td></tr>
<tr class="separator:a67a1b632f9f166ae95a94f161d75f869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bce90c9b23fe653ea5b9d475acc1ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a48bce90c9b23fe653ea5b9d475acc1ab">Affine2Vector</a> (int n, const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x, bool b=false)</td></tr>
<tr class="memdesc:a48bce90c9b23fe653ea5b9d475acc1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>n</em> with all the components initialized to if (!b) <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>x</em>) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>n</em>,i+1,<em>x</em>) }.  <a href="classibex_1_1Affine2Vector.html#a48bce90c9b23fe653ea5b9d475acc1ab">More...</a><br/></td></tr>
<tr class="separator:a48bce90c9b23fe653ea5b9d475acc1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f5c340812aed3095b552f717ede325"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a57f5c340812aed3095b552f717ede325">Affine2Vector</a> (int n, const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a57f5c340812aed3095b552f717ede325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>n</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>n</em> with all the components initialized to <em>x</em>.  <a href="classibex_1_1Affine2Vector.html#a57f5c340812aed3095b552f717ede325">More...</a><br/></td></tr>
<tr class="separator:a57f5c340812aed3095b552f717ede325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844ec68e74a6c640cf40498b6f6fe1a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a844ec68e74a6c640cf40498b6f6fe1a1">Affine2Vector</a> (const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a844ec68e74a6c640cf40498b6f6fe1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <em>x</em>.  <a href="classibex_1_1Affine2Vector.html#a844ec68e74a6c640cf40498b6f6fe1a1">More...</a><br/></td></tr>
<tr class="separator:a844ec68e74a6c640cf40498b6f6fe1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b10dc776b6a9e5536766c46a4ec47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a801b10dc776b6a9e5536766c46a4ec47">Affine2Vector</a> (int n, double bounds[][2], bool b=false)</td></tr>
<tr class="memdesc:a801b10dc776b6a9e5536766c46a4ec47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>n</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> initialized by if !(<em>b</em>) <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(Interval(bounds[i][0],bounds[i][1]) ) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>n</em>, i+1,Interval(bounds[i][0],bounds[i][1]) )  <a href="classibex_1_1Affine2Vector.html#a801b10dc776b6a9e5536766c46a4ec47">More...</a><br/></td></tr>
<tr class="separator:a801b10dc776b6a9e5536766c46a4ec47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1bc5046e623f98c5a898cb7724914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e1bc5046e623f98c5a898cb7724914"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ad7e1bc5046e623f98c5a898cb7724914">Affine2Vector</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x, bool b=false)</td></tr>
<tr class="memdesc:ad7e1bc5046e623f98c5a898cb7724914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>x.size</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>x.size</em> with the [i] component initialized to if !(<em>b</em>) Affine2(x[i]) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(x.size(), i+1,x[i]) <br/></td></tr>
<tr class="separator:ad7e1bc5046e623f98c5a898cb7724914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c112ff08d1b278a58674e0c6e5a4cfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c112ff08d1b278a58674e0c6e5a4cfb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a8c112ff08d1b278a58674e0c6e5a4cfb">Affine2Vector</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a8c112ff08d1b278a58674e0c6e5a4cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the degenerated <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> x. <br/></td></tr>
<tr class="separator:a8c112ff08d1b278a58674e0c6e5a4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1e5102ba78e26ed4c22a3ecc7a57ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c1e5102ba78e26ed4c22a3ecc7a57ed"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a7c1e5102ba78e26ed4c22a3ecc7a57ed">~Affine2Vector</a> ()</td></tr>
<tr class="memdesc:a7c1e5102ba78e26ed4c22a3ecc7a57ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete this vector. <br/></td></tr>
<tr class="separator:a7c1e5102ba78e26ed4c22a3ecc7a57ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af251380504b61f8a5e4e9a50d3de0f53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#af251380504b61f8a5e4e9a50d3de0f53">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:af251380504b61f8a5e4e9a50d3de0f53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>.  <a href="classibex_1_1Affine2Vector.html#af251380504b61f8a5e4e9a50d3de0f53">More...</a><br/></td></tr>
<tr class="separator:af251380504b61f8a5e4e9a50d3de0f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e884b7e0526e07d26870af75728cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ad6e884b7e0526e07d26870af75728cc6">operator[]</a> (int i)</td></tr>
<tr class="memdesc:ad6e884b7e0526e07d26870af75728cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>.  <a href="classibex_1_1Affine2Vector.html#ad6e884b7e0526e07d26870af75728cc6">More...</a><br/></td></tr>
<tr class="separator:ad6e884b7e0526e07d26870af75728cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598876d4112e08207be370357e8b0e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a598876d4112e08207be370357e8b0e18">set_empty</a> ()</td></tr>
<tr class="memdesc:a598876d4112e08207be370357e8b0e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> to the empty <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a>.  <a href="classibex_1_1Affine2Vector.html#a598876d4112e08207be370357e8b0e18">More...</a><br/></td></tr>
<tr class="separator:a598876d4112e08207be370357e8b0e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac7689dc91b7c026a9f5941155d925e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a0ac7689dc91b7c026a9f5941155d925e">clear</a> ()</td></tr>
<tr class="memdesc:a0ac7689dc91b7c026a9f5941155d925e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to 0 (even if empty).  <a href="classibex_1_1Affine2Vector.html#a0ac7689dc91b7c026a9f5941155d925e">More...</a><br/></td></tr>
<tr class="separator:a0ac7689dc91b7c026a9f5941155d925e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af232eb948a9f56df21b19337a97dfc53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#af232eb948a9f56df21b19337a97dfc53">init</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x, bool b=false)</td></tr>
<tr class="memdesc:af232eb948a9f56df21b19337a97dfc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to if !(<em>b</em>) Affine2(x) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(n,i+1,x)  <a href="classibex_1_1Affine2Vector.html#af232eb948a9f56df21b19337a97dfc53">More...</a><br/></td></tr>
<tr class="separator:af232eb948a9f56df21b19337a97dfc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d1e281165ca8d1ca62a2c8b96c82d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a07d1e281165ca8d1ca62a2c8b96c82d6">init</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a07d1e281165ca8d1ca62a2c8b96c82d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to x.  <a href="classibex_1_1Affine2Vector.html#a07d1e281165ca8d1ca62a2c8b96c82d6">More...</a><br/></td></tr>
<tr class="separator:a07d1e281165ca8d1ca62a2c8b96c82d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab604c3c17eae9edd4fe3fa3471dc8413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ab604c3c17eae9edd4fe3fa3471dc8413">inflate</a> (double rad)</td></tr>
<tr class="memdesc:ab604c3c17eae9edd4fe3fa3471dc8413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add [-rad,+rad] to all the components of *this.  <a href="classibex_1_1Affine2Vector.html#ab604c3c17eae9edd4fe3fa3471dc8413">More...</a><br/></td></tr>
<tr class="separator:ab604c3c17eae9edd4fe3fa3471dc8413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05e49707763d298a877fddc1e088d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ab05e49707763d298a877fddc1e088d51">resize</a> (int n2)</td></tr>
<tr class="memdesc:ab05e49707763d298a877fddc1e088d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a>.  <a href="classibex_1_1Affine2Vector.html#ab05e49707763d298a877fddc1e088d51">More...</a><br/></td></tr>
<tr class="separator:ab05e49707763d298a877fddc1e088d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e366e596e675e8af8cd777c23dc863e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a9e366e596e675e8af8cd777c23dc863e">subvector</a> (int start_index, int end_index) const </td></tr>
<tr class="memdesc:a9e366e596e675e8af8cd777c23dc863e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a subvector.  <a href="classibex_1_1Affine2Vector.html#a9e366e596e675e8af8cd777c23dc863e">More...</a><br/></td></tr>
<tr class="separator:a9e366e596e675e8af8cd777c23dc863e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545b8a047c9f1bb290a57d0d1067fb26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a545b8a047c9f1bb290a57d0d1067fb26">put</a> (int start_index, const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;subvec)</td></tr>
<tr class="memdesc:a545b8a047c9f1bb290a57d0d1067fb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a subvector into *this at a given position.  <a href="classibex_1_1Affine2Vector.html#a545b8a047c9f1bb290a57d0d1067fb26">More...</a><br/></td></tr>
<tr class="separator:a545b8a047c9f1bb290a57d0d1067fb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583575dd0f92d446e1ba87f4370b7473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a583575dd0f92d446e1ba87f4370b7473">operator=</a> (const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a583575dd0f92d446e1ba87f4370b7473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> to x.  <a href="classibex_1_1Affine2Vector.html#a583575dd0f92d446e1ba87f4370b7473">More...</a><br/></td></tr>
<tr class="separator:a583575dd0f92d446e1ba87f4370b7473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adcfa31a465977a60ee6909d403396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83adcfa31a465977a60ee6909d403396"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a83adcfa31a465977a60ee6909d403396">operator==</a> (const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;x) const </td></tr>
<tr class="memdesc:a83adcfa31a465977a60ee6909d403396"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true if the bounds of this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> match that of <em>x</em>. <br/></td></tr>
<tr class="separator:a83adcfa31a465977a60ee6909d403396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cdac60834233e3bb71add9f00c835f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9cdac60834233e3bb71add9f00c835f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#af9cdac60834233e3bb71add9f00c835f">operator!=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:af9cdac60834233e3bb71add9f00c835f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true if one bounds of one component of *this differs from <em>x</em>. <br/></td></tr>
<tr class="separator:af9cdac60834233e3bb71add9f00c835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5475de6ae235d7cfe4e9fdddcce5c49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a5475de6ae235d7cfe4e9fdddcce5c49a">itv</a> () const </td></tr>
<tr class="memdesc:a5475de6ae235d7cfe4e9fdddcce5c49a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> compose by the interval of each <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form.  <a href="classibex_1_1Affine2Vector.html#a5475de6ae235d7cfe4e9fdddcce5c49a">More...</a><br/></td></tr>
<tr class="separator:a5475de6ae235d7cfe4e9fdddcce5c49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92023a2589c98d8ff06a15c2b35b785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92023a2589c98d8ff06a15c2b35b785"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#af92023a2589c98d8ff06a15c2b35b785">size</a> () const </td></tr>
<tr class="memdesc:af92023a2589c98d8ff06a15c2b35b785"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension (number of components) <br/></td></tr>
<tr class="separator:af92023a2589c98d8ff06a15c2b35b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7b1af42effe2b40b23c7680b69e73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3a7b1af42effe2b40b23c7680b69e73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ad3a7b1af42effe2b40b23c7680b69e73">is_empty</a> () const </td></tr>
<tr class="memdesc:ad3a7b1af42effe2b40b23c7680b69e73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true iff this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> is empty. <br/></td></tr>
<tr class="separator:ad3a7b1af42effe2b40b23c7680b69e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0af2a671b0763a25c00f25e51be208"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a6e0af2a671b0763a25c00f25e51be208">is_unbounded</a> () const </td></tr>
<tr class="memdesc:a6e0af2a671b0763a25c00f25e51be208"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff this interval vector contains an infinite bound.  <a href="classibex_1_1Affine2Vector.html#a6e0af2a671b0763a25c00f25e51be208">More...</a><br/></td></tr>
<tr class="separator:a6e0af2a671b0763a25c00f25e51be208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80970ac5938321eed652d8e10151bd9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80970ac5938321eed652d8e10151bd9c"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a80970ac5938321eed652d8e10151bd9c">operator+=</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x2)</td></tr>
<tr class="memdesc:a80970ac5938321eed652d8e10151bd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=x2. <br/></td></tr>
<tr class="separator:a80970ac5938321eed652d8e10151bd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1951c4d4f1fbd5cb6fe062e4e2c6561"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1951c4d4f1fbd5cb6fe062e4e2c6561"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#af1951c4d4f1fbd5cb6fe062e4e2c6561">operator+=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x2)</td></tr>
<tr class="memdesc:af1951c4d4f1fbd5cb6fe062e4e2c6561"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=x2. <br/></td></tr>
<tr class="separator:af1951c4d4f1fbd5cb6fe062e4e2c6561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024cfcaa51469464b65d814b43127697"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024cfcaa51469464b65d814b43127697"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a024cfcaa51469464b65d814b43127697">operator-=</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x2)</td></tr>
<tr class="memdesc:a024cfcaa51469464b65d814b43127697"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=x2. <br/></td></tr>
<tr class="separator:a024cfcaa51469464b65d814b43127697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f871327b38ea6a56e57c88fc8e63e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a259f871327b38ea6a56e57c88fc8e63e"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a259f871327b38ea6a56e57c88fc8e63e">operator-=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x2)</td></tr>
<tr class="memdesc:a259f871327b38ea6a56e57c88fc8e63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=x2. <br/></td></tr>
<tr class="separator:a259f871327b38ea6a56e57c88fc8e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93dbccefe734c2a9fd0f9370559b612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93dbccefe734c2a9fd0f9370559b612"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ac93dbccefe734c2a9fd0f9370559b612">operator*=</a> (double d)</td></tr>
<tr class="memdesc:ac93dbccefe734c2a9fd0f9370559b612"><td class="mdescLeft">&#160;</td><td class="mdescRight">x=d*x <br/></td></tr>
<tr class="separator:ac93dbccefe734c2a9fd0f9370559b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dbfb7a26a725e7e7c22094adbd2e45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8dbfb7a26a725e7e7c22094adbd2e45"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#ac8dbfb7a26a725e7e7c22094adbd2e45">operator*=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x1)</td></tr>
<tr class="memdesc:ac8dbfb7a26a725e7e7c22094adbd2e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)=x1</em>(*this). <br/></td></tr>
<tr class="separator:ac8dbfb7a26a725e7e7c22094adbd2e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2141f5432e03f26e515e3b96b71c4e8c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Vector.html#a2141f5432e03f26e515e3b96b71c4e8c">empty</a> (int n)</td></tr>
<tr class="memdesc:a2141f5432e03f26e515e3b96b71c4e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [empty; ...; empty].  <a href="classibex_1_1Affine2Vector.html#a2141f5432e03f26e515e3b96b71c4e8c">More...</a><br/></td></tr>
<tr class="separator:a2141f5432e03f26e515e3b96b71c4e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classibex_1_1Vector.html" title="Vector of reals.">Vector</a> of <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form. </p>
<p>By convention an empty vector has a dimension. A vector becomes empty when one of its component becomes empty and all the components are set to the empty <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a67a1b632f9f166ae95a94f161d75f869"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Vector::Affine2Vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <em>n</em> <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form . All the components are <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>([-oo,+oo]) </p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a48bce90c9b23fe653ea5b9d475acc1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Vector::Affine2Vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>n</em> with all the components initialized to if (!b) <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>x</em>) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>n</em>,i+1,<em>x</em>) }. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a57f5c340812aed3095b552f717ede325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Vector::Affine2Vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <em>n</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>n</em> with all the components initialized to <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a844ec68e74a6c640cf40498b6f6fe1a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Vector::Affine2Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a copy of <em>x</em>. </p>
<p>Create a copy of { <em>x</em> if !(<em>b</em>) else -(<em>x</em>) }. </p>

</div>
</div>
<a class="anchor" id="a801b10dc776b6a9e5536766c46a4ec47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Vector::Affine2Vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bounds</em>[][2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <em>n</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> initialized by if !(<em>b</em>) <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(Interval(bounds[i][0],bounds[i][1]) ) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(<em>n</em>, i+1,Interval(bounds[i][0],bounds[i][1]) ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>an nx2 array of doubles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2141f5432e03f26e515e3b96b71c4e8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> ibex::Affine2Vector::empty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create [empty; ...; empty]. </p>
<p>Create an empty <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>n</em> (all the components being empty Intervals)</p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="af251380504b61f8a5e4e9a50d3de0f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp; ibex::Affine2Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>. </p>
<p>A return a const reference to the i^th component (i starts from 0) </p>

</div>
</div>
<a class="anchor" id="ad6e884b7e0526e07d26870af75728cc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp; ibex::Affine2Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>. </p>
<p>A return a non-const reference to the i^th component (i starts from 0) </p>

</div>
</div>
<a class="anchor" id="a598876d4112e08207be370357e8b0e18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::set_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> to the empty <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a>. </p>
<p>The dimension remains the same. </p>

</div>
</div>
<a class="anchor" id="a0ac7689dc91b7c026a9f5941155d925e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all the elements to 0 (even if empty). </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="af232eb948a9f56df21b19337a97dfc53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the elements to if !(<em>b</em>) Affine2(x) else <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a>(n,i+1,x) </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="a07d1e281165ca8d1ca62a2c8b96c82d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the elements to x. </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="ab604c3c17eae9edd4fe3fa3471dc8413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a>&amp; ibex::Affine2Vector::inflate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add [-rad,+rad] to all the components of *this. </p>
<dl class="section return"><dt>Returns</dt><dd>*this. </dd></dl>

</div>
</div>
<a class="anchor" id="ab05e49707763d298a877fddc1e088d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a>. </p>
<p>If the size is increased, the existing components are not modified and the new ones are set to (ZERO), even if (*this) is the empty <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a> (however, in this case, the status of (*this) remains "empty"). </p>

</div>
</div>
<a class="anchor" id="a9e366e596e675e8af8cd777c23dc863e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> ibex::Affine2Vector::subvector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> a subvector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must not be empty </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>[ (*this)[start_index]; ...; (*this)[end_index] ]. </dd></dl>

</div>
</div>
<a class="anchor" id="a545b8a047c9f1bb290a57d0d1067fb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Vector::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>subvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a subvector into *this at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>- the position where the subvector </td></tr>
    <tr><td class="paramname">subvec</td><td>- the subvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must not be empty </dd></dl>

</div>
</div>
<a class="anchor" id="a583575dd0f92d446e1ba87f4370b7473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a>&amp; ibex::Affine2Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign this <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> to x. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimensions of this and x must match. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emptiness is overridden. </dd></dl>

</div>
</div>
<a class="anchor" id="a5475de6ae235d7cfe4e9fdddcce5c49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> ibex::Affine2Vector::itv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> compose by the interval of each <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a6e0af2a671b0763a25c00f25e51be208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Affine2Vector::is_unbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff this interval vector contains an infinite bound. </p>
<dl class="section note"><dt>Note</dt><dd>An empty interval vector is always bounded. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibex/ibex_Affine2Vector.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 26 2013 10:27:35 for IBEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

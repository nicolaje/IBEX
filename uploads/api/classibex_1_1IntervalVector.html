<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>IBEX: ibex::IntervalVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!!
-->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
function scroll(id) {
        var offset = $(id).offset().top; 
	$('html,body', window.parent.document).animate({scrollTop: offset}, 'fast');
}
</script>
</head>
<body>
<div id="top" style="background-image: url(../NCleanBlue/ibexbg960.png) no-repeat right;"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibex</b></li><li class="navelem"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classibex_1_1IntervalVector.html#pub-methods">Public Member Functions</a> &#124;
<a href="classibex_1_1IntervalVector.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classibex_1_1IntervalVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibex::IntervalVector Class Reference<div class="ingroups"><a class="el" href="group__arithmetic.html">Interval Arithmetic</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classibex_1_1Vector.html" title="Vector of reals.">Vector</a> of Intervals.  
 <a href="classibex_1_1IntervalVector.html#details">More...</a></p>

<p><code>#include &lt;ibex_IntervalVector.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addc83f865ebc8baab852703e37814d45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#addc83f865ebc8baab852703e37814d45">IntervalVector</a> (int n)</td></tr>
<tr class="memdesc:addc83f865ebc8baab852703e37814d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [(-oo,+oo) ; ..; (-oo,+oo)].  <a href="classibex_1_1IntervalVector.html#addc83f865ebc8baab852703e37814d45">More...</a><br/></td></tr>
<tr class="separator:addc83f865ebc8baab852703e37814d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1698b3bd0923dd9335200015ebeb9912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a1698b3bd0923dd9335200015ebeb9912">IntervalVector</a> (int n, const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a1698b3bd0923dd9335200015ebeb9912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [x; ....; x].  <a href="classibex_1_1IntervalVector.html#a1698b3bd0923dd9335200015ebeb9912">More...</a><br/></td></tr>
<tr class="separator:a1698b3bd0923dd9335200015ebeb9912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3d8cb43d7b4ecbe6ad9798d49b8ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade3d8cb43d7b4ecbe6ad9798d49b8ee5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ade3d8cb43d7b4ecbe6ad9798d49b8ee5">IntervalVector</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x)</td></tr>
<tr class="memdesc:ade3d8cb43d7b4ecbe6ad9798d49b8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <em>x</em>. <br/></td></tr>
<tr class="separator:ade3d8cb43d7b4ecbe6ad9798d49b8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8c3fa061398c71a1108d2689d4ed0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#acf8c3fa061398c71a1108d2689d4ed0b">IntervalVector</a> (int n, double bounds[][2])</td></tr>
<tr class="memdesc:acf8c3fa061398c71a1108d2689d4ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> [bounds[0][0],bounds[0][1]]x...x[bounds[n-1][0],bounds[n-1][1]].  <a href="classibex_1_1IntervalVector.html#acf8c3fa061398c71a1108d2689d4ed0b">More...</a><br/></td></tr>
<tr class="separator:acf8c3fa061398c71a1108d2689d4ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdafb6086e079d8b86708efa97a7a29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdafb6086e079d8b86708efa97a7a29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a6cdafb6086e079d8b86708efa97a7a29">IntervalVector</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x)</td></tr>
<tr class="memdesc:a6cdafb6086e079d8b86708efa97a7a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the degenerated <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> x. <br/></td></tr>
<tr class="separator:a6cdafb6086e079d8b86708efa97a7a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78921117ce0fd63bcb68f023f8a988e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78921117ce0fd63bcb68f023f8a988e2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a78921117ce0fd63bcb68f023f8a988e2">~IntervalVector</a> ()</td></tr>
<tr class="memdesc:a78921117ce0fd63bcb68f023f8a988e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete this vector. <br/></td></tr>
<tr class="separator:a78921117ce0fd63bcb68f023f8a988e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b56269b4a37259f90d48af97251197"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a66b56269b4a37259f90d48af97251197">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:a66b56269b4a37259f90d48af97251197"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>.  <a href="classibex_1_1IntervalVector.html#a66b56269b4a37259f90d48af97251197">More...</a><br/></td></tr>
<tr class="separator:a66b56269b4a37259f90d48af97251197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815bb9c26deff685fdabd0fbf356483b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a815bb9c26deff685fdabd0fbf356483b">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a815bb9c26deff685fdabd0fbf356483b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>.  <a href="classibex_1_1IntervalVector.html#a815bb9c26deff685fdabd0fbf356483b">More...</a><br/></td></tr>
<tr class="separator:a815bb9c26deff685fdabd0fbf356483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dd1667f5fa0782e3013f1d3ac66093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a43dd1667f5fa0782e3013f1d3ac66093">set_empty</a> ()</td></tr>
<tr class="memdesc:a43dd1667f5fa0782e3013f1d3ac66093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to the empty <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a>.  <a href="classibex_1_1IntervalVector.html#a43dd1667f5fa0782e3013f1d3ac66093">More...</a><br/></td></tr>
<tr class="separator:a43dd1667f5fa0782e3013f1d3ac66093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4a62b66389d7090be02b8d5c41ee23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#acc4a62b66389d7090be02b8d5c41ee23">clear</a> ()</td></tr>
<tr class="memdesc:acc4a62b66389d7090be02b8d5c41ee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to 0 (even if empty).  <a href="classibex_1_1IntervalVector.html#acc4a62b66389d7090be02b8d5c41ee23">More...</a><br/></td></tr>
<tr class="separator:acc4a62b66389d7090be02b8d5c41ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9448b16bc571de77d86009b264674bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a9448b16bc571de77d86009b264674bd2">init</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a9448b16bc571de77d86009b264674bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to x (even if empty).  <a href="classibex_1_1IntervalVector.html#a9448b16bc571de77d86009b264674bd2">More...</a><br/></td></tr>
<tr class="separator:a9448b16bc571de77d86009b264674bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b69d3ca7e64cf1f60b9d7c08652ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a14b69d3ca7e64cf1f60b9d7c08652ea7">inflate</a> (double <a class="el" href="classibex_1_1IntervalVector.html#a085a5e5a2f6bba3b67ec0881a13c8688">rad</a>)</td></tr>
<tr class="memdesc:a14b69d3ca7e64cf1f60b9d7c08652ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add [-rad,+rad] to all the components of *this.  <a href="classibex_1_1IntervalVector.html#a14b69d3ca7e64cf1f60b9d7c08652ea7">More...</a><br/></td></tr>
<tr class="separator:a14b69d3ca7e64cf1f60b9d7c08652ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06e69c94e382d9526a618a676bce474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aa06e69c94e382d9526a618a676bce474">resize</a> (int n2)</td></tr>
<tr class="memdesc:aa06e69c94e382d9526a618a676bce474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a>.  <a href="classibex_1_1IntervalVector.html#aa06e69c94e382d9526a618a676bce474">More...</a><br/></td></tr>
<tr class="separator:aa06e69c94e382d9526a618a676bce474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b82a33fa29e9fecbd1c0a60f1e91d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a83b82a33fa29e9fecbd1c0a60f1e91d7">subvector</a> (int start_index, int end_index) const </td></tr>
<tr class="memdesc:a83b82a33fa29e9fecbd1c0a60f1e91d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a subvector.  <a href="classibex_1_1IntervalVector.html#a83b82a33fa29e9fecbd1c0a60f1e91d7">More...</a><br/></td></tr>
<tr class="separator:a83b82a33fa29e9fecbd1c0a60f1e91d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e980936cee06bd56ef3cf850eb4b14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ab8e980936cee06bd56ef3cf850eb4b14">put</a> (int start_index, const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;subvec)</td></tr>
<tr class="memdesc:ab8e980936cee06bd56ef3cf850eb4b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put a subvector into *this at a given position.  <a href="classibex_1_1IntervalVector.html#ab8e980936cee06bd56ef3cf850eb4b14">More...</a><br/></td></tr>
<tr class="separator:ab8e980936cee06bd56ef3cf850eb4b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a87daa4a5ff0653c0f4ff30bc219a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ac60a87daa4a5ff0653c0f4ff30bc219a">operator=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x)</td></tr>
<tr class="memdesc:ac60a87daa4a5ff0653c0f4ff30bc219a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to x.  <a href="classibex_1_1IntervalVector.html#ac60a87daa4a5ff0653c0f4ff30bc219a">More...</a><br/></td></tr>
<tr class="separator:ac60a87daa4a5ff0653c0f4ff30bc219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b10401cd0c411356338df78683f344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ae5b10401cd0c411356338df78683f344">operator&amp;=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x)</td></tr>
<tr class="memdesc:ae5b10401cd0c411356338df78683f344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to its intersection with x.  <a href="classibex_1_1IntervalVector.html#ae5b10401cd0c411356338df78683f344">More...</a><br/></td></tr>
<tr class="separator:ae5b10401cd0c411356338df78683f344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1f615bbd83c592bcf7b8234d3a4de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a3e1f615bbd83c592bcf7b8234d3a4de8">operator|=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x)</td></tr>
<tr class="memdesc:a3e1f615bbd83c592bcf7b8234d3a4de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to the hull of itself and another.  <a href="classibex_1_1IntervalVector.html#a3e1f615bbd83c592bcf7b8234d3a4de8">More...</a><br/></td></tr>
<tr class="separator:a3e1f615bbd83c592bcf7b8234d3a4de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db0fa38cc29a6676774d991784bc639"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db0fa38cc29a6676774d991784bc639"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a6db0fa38cc29a6676774d991784bc639">operator&amp;</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:a6db0fa38cc29a6676774d991784bc639"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the intersection of this and x. <br/></td></tr>
<tr class="separator:a6db0fa38cc29a6676774d991784bc639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe290433acd187282581823e81464ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe290433acd187282581823e81464ef"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#adbe290433acd187282581823e81464ef">operator|</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:adbe290433acd187282581823e81464ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the hull of this &amp; x. <br/></td></tr>
<tr class="separator:adbe290433acd187282581823e81464ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ea0b3e78d2eb37352f3380c5aeb31c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ea0b3e78d2eb37352f3380c5aeb31c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a30ea0b3e78d2eb37352f3380c5aeb31c">operator==</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:a30ea0b3e78d2eb37352f3380c5aeb31c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true if the bounds of this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> match that of <em>x</em>. <br/></td></tr>
<tr class="separator:a30ea0b3e78d2eb37352f3380c5aeb31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91908779e2c8a998061bad3ca9b51826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91908779e2c8a998061bad3ca9b51826"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a91908779e2c8a998061bad3ca9b51826">operator!=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:a91908779e2c8a998061bad3ca9b51826"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true if one bounds of one component of *this differs from <em>x</em>. <br/></td></tr>
<tr class="separator:a91908779e2c8a998061bad3ca9b51826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42449c256026d5a525a38f16c3241247"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42449c256026d5a525a38f16c3241247"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a42449c256026d5a525a38f16c3241247">size</a> () const </td></tr>
<tr class="memdesc:a42449c256026d5a525a38f16c3241247"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension (number of components) <br/></td></tr>
<tr class="separator:a42449c256026d5a525a38f16c3241247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a478a542027dc1465962b608b39a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a80a478a542027dc1465962b608b39a21">lb</a> () const </td></tr>
<tr class="memdesc:a80a478a542027dc1465962b608b39a21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the lower bound vector.  <a href="classibex_1_1IntervalVector.html#a80a478a542027dc1465962b608b39a21">More...</a><br/></td></tr>
<tr class="separator:a80a478a542027dc1465962b608b39a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0715a1e535696c36325cadb450c76b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a0715a1e535696c36325cadb450c76b61">ub</a> () const </td></tr>
<tr class="memdesc:a0715a1e535696c36325cadb450c76b61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the upper bound vector.  <a href="classibex_1_1IntervalVector.html#a0715a1e535696c36325cadb450c76b61">More...</a><br/></td></tr>
<tr class="separator:a0715a1e535696c36325cadb450c76b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31bd647a784b1b814536c4bcfd39fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aa31bd647a784b1b814536c4bcfd39fa5">mid</a> () const </td></tr>
<tr class="memdesc:aa31bd647a784b1b814536c4bcfd39fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the midpoint.  <a href="classibex_1_1IntervalVector.html#aa31bd647a784b1b814536c4bcfd39fa5">More...</a><br/></td></tr>
<tr class="separator:aa31bd647a784b1b814536c4bcfd39fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f4c78c7bdd4706fbb9e0f7b1321e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a6a6f4c78c7bdd4706fbb9e0f7b1321e1">mig</a> () const </td></tr>
<tr class="memdesc:a6a6f4c78c7bdd4706fbb9e0f7b1321e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the mignitude vector.  <a href="classibex_1_1IntervalVector.html#a6a6f4c78c7bdd4706fbb9e0f7b1321e1">More...</a><br/></td></tr>
<tr class="separator:a6a6f4c78c7bdd4706fbb9e0f7b1321e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14975acaf4407f6a6ca64cb2c7b175f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#af14975acaf4407f6a6ca64cb2c7b175f">mag</a> () const </td></tr>
<tr class="memdesc:af14975acaf4407f6a6ca64cb2c7b175f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the magnitude vector.  <a href="classibex_1_1IntervalVector.html#af14975acaf4407f6a6ca64cb2c7b175f">More...</a><br/></td></tr>
<tr class="separator:af14975acaf4407f6a6ca64cb2c7b175f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76281e6b61a9cabc7e8a4c22986711d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab76281e6b61a9cabc7e8a4c22986711d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ab76281e6b61a9cabc7e8a4c22986711d">is_empty</a> () const </td></tr>
<tr class="memdesc:ab76281e6b61a9cabc7e8a4c22986711d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true iff this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is empty. <br/></td></tr>
<tr class="separator:ab76281e6b61a9cabc7e8a4c22986711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e67207986b367b25047b8c573c147c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a0e67207986b367b25047b8c573c147c0">is_flat</a> () const </td></tr>
<tr class="memdesc:a0e67207986b367b25047b8c573c147c0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true iff this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is flat.  <a href="classibex_1_1IntervalVector.html#a0e67207986b367b25047b8c573c147c0">More...</a><br/></td></tr>
<tr class="separator:a0e67207986b367b25047b8c573c147c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e802cc3e03ac28e5a5970a372340a7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a8e802cc3e03ac28e5a5970a372340a7b">contains</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x) const </td></tr>
<tr class="memdesc:a8e802cc3e03ac28e5a5970a372340a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval vector contains <em>x</em>.  <a href="classibex_1_1IntervalVector.html#a8e802cc3e03ac28e5a5970a372340a7b">More...</a><br/></td></tr>
<tr class="separator:a8e802cc3e03ac28e5a5970a372340a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4998035f3ec164eff053ae3c71e55ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aa4998035f3ec164eff053ae3c71e55ff">is_unbounded</a> () const </td></tr>
<tr class="memdesc:aa4998035f3ec164eff053ae3c71e55ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff this interval vector contains an infinite bound.  <a href="classibex_1_1IntervalVector.html#aa4998035f3ec164eff053ae3c71e55ff">More...</a><br/></td></tr>
<tr class="separator:aa4998035f3ec164eff053ae3c71e55ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287f77f99507866c2f0f2d613720809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a3287f77f99507866c2f0f2d613720809">is_subset</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:a3287f77f99507866c2f0f2d613720809"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval vector is a subset of <em>x</em>.  <a href="classibex_1_1IntervalVector.html#a3287f77f99507866c2f0f2d613720809">More...</a><br/></td></tr>
<tr class="separator:a3287f77f99507866c2f0f2d613720809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45ae303df433fad9af523713f6fd48c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ac45ae303df433fad9af523713f6fd48c">is_strict_subset</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:ac45ae303df433fad9af523713f6fd48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval vector is inside the interior of <em>x</em>.  <a href="classibex_1_1IntervalVector.html#ac45ae303df433fad9af523713f6fd48c">More...</a><br/></td></tr>
<tr class="separator:ac45ae303df433fad9af523713f6fd48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff08393670958ba74150735f4639521"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#acff08393670958ba74150735f4639521">is_superset</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:acff08393670958ba74150735f4639521"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff this interval vector is a superset of <em>x</em>.  <a href="classibex_1_1IntervalVector.html#acff08393670958ba74150735f4639521">More...</a><br/></td></tr>
<tr class="separator:acff08393670958ba74150735f4639521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bbceaddaf48829e1e9466013d7237e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a27bbceaddaf48829e1e9466013d7237e">is_strict_superset</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:a27bbceaddaf48829e1e9466013d7237e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff <em>x</em> is inside the interior of (*this).  <a href="classibex_1_1IntervalVector.html#a27bbceaddaf48829e1e9466013d7237e">More...</a><br/></td></tr>
<tr class="separator:a27bbceaddaf48829e1e9466013d7237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718180973e25ab0460f316b0335049b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a718180973e25ab0460f316b0335049b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a718180973e25ab0460f316b0335049b7">is_zero</a> () const </td></tr>
<tr class="memdesc:a718180973e25ab0460f316b0335049b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this is a vector of zeros. <br/></td></tr>
<tr class="separator:a718180973e25ab0460f316b0335049b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0184e3c4cabf7becf9781d752461fdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ab0184e3c4cabf7becf9781d752461fdf">is_bisectable</a> () const </td></tr>
<tr class="memdesc:ab0184e3c4cabf7becf9781d752461fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this can be bisected along one dimension.  <a href="classibex_1_1IntervalVector.html#ab0184e3c4cabf7becf9781d752461fdf">More...</a><br/></td></tr>
<tr class="separator:ab0184e3c4cabf7becf9781d752461fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085a5e5a2f6bba3b67ec0881a13c8688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a085a5e5a2f6bba3b67ec0881a13c8688"></a>
<a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a085a5e5a2f6bba3b67ec0881a13c8688">rad</a> () const </td></tr>
<tr class="memdesc:a085a5e5a2f6bba3b67ec0881a13c8688"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Vector.html" title="Vector of reals.">Vector</a> of radii. <br/></td></tr>
<tr class="separator:a085a5e5a2f6bba3b67ec0881a13c8688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758d79aaa9b548959633cefa58b841b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a758d79aaa9b548959633cefa58b841b8"></a>
<a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a758d79aaa9b548959633cefa58b841b8">diam</a> () const </td></tr>
<tr class="memdesc:a758d79aaa9b548959633cefa58b841b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the vector of diameters. <br/></td></tr>
<tr class="separator:a758d79aaa9b548959633cefa58b841b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0291695531aa8d6b32feb7d7ff52afe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a0291695531aa8d6b32feb7d7ff52afe3">extr_diam_index</a> (bool min) const </td></tr>
<tr class="memdesc:a0291695531aa8d6b32feb7d7ff52afe3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the index of a component with minimal/maximal diameter.  <a href="classibex_1_1IntervalVector.html#a0291695531aa8d6b32feb7d7ff52afe3">More...</a><br/></td></tr>
<tr class="separator:a0291695531aa8d6b32feb7d7ff52afe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3438ddff092cdb67828d5af2747bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f3438ddff092cdb67828d5af2747bcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a9f3438ddff092cdb67828d5af2747bcc">sort_indices</a> (bool min, int tab[]) const </td></tr>
<tr class="memdesc:a9f3438ddff092cdb67828d5af2747bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the indices of all the components, sorted by increasing/decreasing diameter. <br/></td></tr>
<tr class="separator:a9f3438ddff092cdb67828d5af2747bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f72908d03af672b9440a4d3bc691b2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a99f72908d03af672b9440a4d3bc691b2">max_diam</a> () const </td></tr>
<tr class="memdesc:a99f72908d03af672b9440a4d3bc691b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the maximal diameter among all the components.  <a href="classibex_1_1IntervalVector.html#a99f72908d03af672b9440a4d3bc691b2">More...</a><br/></td></tr>
<tr class="separator:a99f72908d03af672b9440a4d3bc691b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a05c46adc1018185433a19796ec89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ae95a05c46adc1018185433a19796ec89">min_diam</a> () const </td></tr>
<tr class="memdesc:ae95a05c46adc1018185433a19796ec89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the minimal diameter among all the components.  <a href="classibex_1_1IntervalVector.html#ae95a05c46adc1018185433a19796ec89">More...</a><br/></td></tr>
<tr class="separator:ae95a05c46adc1018185433a19796ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93843f0348a8f4ea1e6a77a1c40f8d6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a93843f0348a8f4ea1e6a77a1c40f8d6e">volume</a> () const </td></tr>
<tr class="memdesc:a93843f0348a8f4ea1e6a77a1c40f8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the volume of this interval vector.  <a href="classibex_1_1IntervalVector.html#a93843f0348a8f4ea1e6a77a1c40f8d6e">More...</a><br/></td></tr>
<tr class="separator:a93843f0348a8f4ea1e6a77a1c40f8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08799e4c37b776dd27053e07dc99a97"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ab08799e4c37b776dd27053e07dc99a97">perimeter</a> () const </td></tr>
<tr class="memdesc:ab08799e4c37b776dd27053e07dc99a97"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the perimeter of this interval vector.  <a href="classibex_1_1IntervalVector.html#ab08799e4c37b776dd27053e07dc99a97">More...</a><br/></td></tr>
<tr class="separator:ab08799e4c37b776dd27053e07dc99a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61cb5b387d46785b0d6bf37c2f24097"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ae61cb5b387d46785b0d6bf37c2f24097">maxdelta</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;)</td></tr>
<tr class="memdesc:ae61cb5b387d46785b0d6bf37c2f24097"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> max of the delta, for x *this [deprecated].  <a href="classibex_1_1IntervalVector.html#ae61cb5b387d46785b0d6bf37c2f24097">More...</a><br/></td></tr>
<tr class="separator:ae61cb5b387d46785b0d6bf37c2f24097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5547726485722595aa9fd2ba069cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aadf5547726485722595aa9fd2ba069cb">rel_distance</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x) const </td></tr>
<tr class="memdesc:aadf5547726485722595aa9fd2ba069cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the relative distance with x.  <a href="classibex_1_1IntervalVector.html#aadf5547726485722595aa9fd2ba069cb">More...</a><br/></td></tr>
<tr class="separator:aadf5547726485722595aa9fd2ba069cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8e7614adde40bbc5ea75639495e972"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#afd8e7614adde40bbc5ea75639495e972">diff</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;y, <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> *&amp;result) const </td></tr>
<tr class="memdesc:afd8e7614adde40bbc5ea75639495e972"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> *this \ y (set difference).  <a href="classibex_1_1IntervalVector.html#afd8e7614adde40bbc5ea75639495e972">More...</a><br/></td></tr>
<tr class="separator:afd8e7614adde40bbc5ea75639495e972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3b55c49cdaebc22ea0379f3aa03ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ab3d3b55c49cdaebc22ea0379f3aa03ea">complementary</a> (<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> *&amp;result) const </td></tr>
<tr class="memdesc:ab3d3b55c49cdaebc22ea0379f3aa03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the complementary of *this.  <a href="classibex_1_1IntervalVector.html#ab3d3b55c49cdaebc22ea0379f3aa03ea">More...</a><br/></td></tr>
<tr class="separator:ab3d3b55c49cdaebc22ea0379f3aa03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17899009786991d85b5533ea69f8a26"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>, <br class="typebreak"/>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ae17899009786991d85b5533ea69f8a26">bisect</a> (int i, double ratio=0.5) const </td></tr>
<tr class="memdesc:ae17899009786991d85b5533ea69f8a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect the box.  <a href="classibex_1_1IntervalVector.html#ae17899009786991d85b5533ea69f8a26">More...</a><br/></td></tr>
<tr class="separator:ae17899009786991d85b5533ea69f8a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f1958efa1b60636f1ee9dbebb22264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aa1f1958efa1b60636f1ee9dbebb22264">random</a> () const </td></tr>
<tr class="memdesc:aa1f1958efa1b60636f1ee9dbebb22264"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a random vector inside *this.  <a href="classibex_1_1IntervalVector.html#aa1f1958efa1b60636f1ee9dbebb22264">More...</a><br/></td></tr>
<tr class="separator:aa1f1958efa1b60636f1ee9dbebb22264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7323d40fc41fc38d828083f91d2ceb57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7323d40fc41fc38d828083f91d2ceb57"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a7323d40fc41fc38d828083f91d2ceb57">operator+=</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x2)</td></tr>
<tr class="memdesc:a7323d40fc41fc38d828083f91d2ceb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=x2. <br/></td></tr>
<tr class="separator:a7323d40fc41fc38d828083f91d2ceb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353eb5545358d264d263158143b52c48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a353eb5545358d264d263158143b52c48"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a353eb5545358d264d263158143b52c48">operator+=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x2)</td></tr>
<tr class="memdesc:a353eb5545358d264d263158143b52c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=x2. <br/></td></tr>
<tr class="separator:a353eb5545358d264d263158143b52c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74cb235309977be7857f26dea528e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec74cb235309977be7857f26dea528e8"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#aec74cb235309977be7857f26dea528e8">operator-=</a> (const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;x2)</td></tr>
<tr class="memdesc:aec74cb235309977be7857f26dea528e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=x2. <br/></td></tr>
<tr class="separator:aec74cb235309977be7857f26dea528e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35acbb809f20688e57f1d9b5b498de6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35acbb809f20688e57f1d9b5b498de6d"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a35acbb809f20688e57f1d9b5b498de6d">operator-=</a> (const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;x2)</td></tr>
<tr class="memdesc:a35acbb809f20688e57f1d9b5b498de6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=x2. <br/></td></tr>
<tr class="separator:a35acbb809f20688e57f1d9b5b498de6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7fb42b0d1c267ff95d3cf6adf1726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d7fb42b0d1c267ff95d3cf6adf1726"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a53d7fb42b0d1c267ff95d3cf6adf1726">operator*=</a> (double d)</td></tr>
<tr class="memdesc:a53d7fb42b0d1c267ff95d3cf6adf1726"><td class="mdescLeft">&#160;</td><td class="mdescRight">x=d*x <br/></td></tr>
<tr class="separator:a53d7fb42b0d1c267ff95d3cf6adf1726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd7a8e3aa4591ea708dfddd7a6544c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4cd7a8e3aa4591ea708dfddd7a6544c"></a>
<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#ad4cd7a8e3aa4591ea708dfddd7a6544c">operator*=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x1)</td></tr>
<tr class="memdesc:ad4cd7a8e3aa4591ea708dfddd7a6544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)=x1</em>(*this). <br/></td></tr>
<tr class="separator:ad4cd7a8e3aa4591ea708dfddd7a6544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9bc9714ab42f76e27e648f9f30af2314"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1IntervalVector.html#a9bc9714ab42f76e27e648f9f30af2314">empty</a> (int n)</td></tr>
<tr class="memdesc:a9bc9714ab42f76e27e648f9f30af2314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create [empty; ...; empty].  <a href="classibex_1_1IntervalVector.html#a9bc9714ab42f76e27e648f9f30af2314">More...</a><br/></td></tr>
<tr class="separator:a9bc9714ab42f76e27e648f9f30af2314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classibex_1_1Vector.html" title="Vector of reals.">Vector</a> of Intervals. </p>
<p>By convention an empty vector has a dimension. A vector becomes empty when one of its component becomes empty and all the components are set to the empty <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="addc83f865ebc8baab852703e37814d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibex::IntervalVector::IntervalVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create [(-oo,+oo) ; ..; (-oo,+oo)]. </p>
<p>Create a n-sized vector. All the components are (-oo,+oo) </p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1698b3bd0923dd9335200015ebeb9912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::IntervalVector::IntervalVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create [x; ....; x]. </p>
<p>Create a <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> of dimension <em>n</em> with all the components initialized to <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="acf8c3fa061398c71a1108d2689d4ed0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::IntervalVector::IntervalVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bounds</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> [bounds[0][0],bounds[0][1]]x...x[bounds[n-1][0],bounds[n-1][1]]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>an nx2 array of doubles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9bc9714ab42f76e27e648f9f30af2314"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> ibex::IntervalVector::empty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create [empty; ...; empty]. </p>
<p>Create an empty <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> of dimension <em>n</em> (all the components being empty Intervals)</p>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a66b56269b4a37259f90d48af97251197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp; ibex::IntervalVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>. </p>
<p>A return a const reference to the i^th component (i starts from 0) </p>

</div>
</div>
<a class="anchor" id="a815bb9c26deff685fdabd0fbf356483b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Interval.html">Interval</a> &amp; ibex::IntervalVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a>. </p>
<p>A return a non-const reference to the i^th component (i starts from 0) </p>

</div>
</div>
<a class="anchor" id="a43dd1667f5fa0782e3013f1d3ac66093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::IntervalVector::set_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to the empty <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a>. </p>
<p>The dimension remains the same. </p>

</div>
</div>
<a class="anchor" id="acc4a62b66389d7090be02b8d5c41ee23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::IntervalVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all the elements to 0 (even if empty). </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="a9448b16bc571de77d86009b264674bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::IntervalVector::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the elements to x (even if empty). </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="a14b69d3ca7e64cf1f60b9d7c08652ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&amp; ibex::IntervalVector::inflate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add [-rad,+rad] to all the components of *this. </p>
<dl class="section return"><dt>Returns</dt><dd>*this. </dd></dl>

</div>
</div>
<a class="anchor" id="aa06e69c94e382d9526a618a676bce474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::IntervalVector::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a>. </p>
<p>If the size is increased, the existing components are not modified and the new ones are set to (-inf,+inf), even if (*this) is the empty <a class="el" href="classibex_1_1Interval.html" title="Interval.">Interval</a> (however, in this case, the status of (*this) remains "empty"). </p>

</div>
</div>
<a class="anchor" id="a83b82a33fa29e9fecbd1c0a60f1e91d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> ibex::IntervalVector::subvector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> a subvector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must not be empty </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>[ (*this)[start_index]; ...; (*this)[end_index] ]. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e980936cee06bd56ef3cf850eb4b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::IntervalVector::put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>subvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put a subvector into *this at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>- the position where the subvector </td></tr>
    <tr><td class="paramname">subvec</td><td>- the subvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must not be empty </dd></dl>

</div>
</div>
<a class="anchor" id="ac60a87daa4a5ff0653c0f4ff30bc219a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&amp; ibex::IntervalVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to x. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimensions of this and x must match. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emptiness is overridden. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5b10401cd0c411356338df78683f344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&amp; ibex::IntervalVector::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set *this to its intersection with x. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classibex_1_1InvalidIntervalVectorOp.html" title="Base class for all exceptions raised by an operation on an interval vector.">InvalidIntervalVectorOp</a></td><td>if the vectors do not have the same dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e1f615bbd83c592bcf7b8234d3a4de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&amp; ibex::IntervalVector::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> to the hull of itself and another. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classibex_1_1InvalidIntervalVectorOp.html" title="Base class for all exceptions raised by an operation on an interval vector.">InvalidIntervalVectorOp</a></td><td>if IntervalVectores do not have the same dimensions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80a478a542027dc1465962b608b39a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::lb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the lower bound vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a0715a1e535696c36325cadb450c76b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::ub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the upper bound vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="aa31bd647a784b1b814536c4bcfd39fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::mid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the midpoint. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a6a6f4c78c7bdd4706fbb9e0f7b1321e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::mig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the mignitude vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="af14975acaf4407f6a6ca64cb2c7b175f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::mag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the magnitude vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a0e67207986b367b25047b8c573c147c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_flat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> true iff this <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is flat. </p>
<p>An <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is "flat" if the radius is 0 on at least one dimension An empty interval vector is considered as flat. </p>

</div>
</div>
<a class="anchor" id="a8e802cc3e03ac28e5a5970a372340a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff this interval vector contains <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimension of <em>x</em> must be equal to the dimension of (*this). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#abda5f9522a19322e794459d44b838bb5" title="True iff *this contains d.">ibex::Interval::contains(double) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4998035f3ec164eff053ae3c71e55ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_unbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff this interval vector contains an infinite bound. </p>
<dl class="section note"><dt>Note</dt><dd>An empty interval vector is always bounded. </dd></dl>

</div>
</div>
<a class="anchor" id="a3287f77f99507866c2f0f2d613720809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_subset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff this interval vector is a subset of <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimension of <em>x</em> must be equal to the dimension of this vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always return true if this interval vector is empty.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#ab9138d2d5cb7c3ee8a6a34605f44bcaa" title="True iff this interval is a subset of x.">ibex::Interval::is_subset(const Interval&amp;) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac45ae303df433fad9af523713f6fd48c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_strict_subset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff this interval vector is inside the interior of <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimension of <em>x</em> must be equal to the dimension of this vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>return true if this interval vector is empty and <em>x</em> not.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#ab6ee2d643bd42794bcdca365284cff38" title="True iff this interval is in the interior of x.">ibex::Interval::is_strict_subset(const Interval&amp;) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acff08393670958ba74150735f4639521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_superset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True iff this interval vector is a superset of <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimension of <em>x</em> must be equal to the dimension of this vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Always return true if <em>x</em> is empty.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#a92190f8eaf229278239cbff705a5618b" title="True iff this interval is a superset of x.">ibex::Interval::is_superset(const Interval&amp;) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a27bbceaddaf48829e1e9466013d7237e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_strict_superset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True iff <em>x</em> is inside the interior of (*this). </p>
<dl class="section pre"><dt>Precondition</dt><dd>Dimension of <em>x</em> must be equal to the dimension of this vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>return true if x is empty and not (*this).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#a0c460c9d128f07b298d222f1a8719792" title="True iff the interior of *this is a superset of x.">ibex::Interval::is_strict_superset(const Interval&amp;) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0184e3c4cabf7becf9781d752461fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::IntervalVector::is_bisectable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff *this can be bisected along one dimension. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classibex_1_1Interval.html#a5fe49b5e7755710b35ed39fe1705f2cc" title="True iff *this can be bisected into two non-degenerated intervals.">ibex::Interval::is_bisectable()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0291695531aa8d6b32feb7d7ff52afe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ibex::IntervalVector::extr_diam_index </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the index of a component with minimal/maximal diameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>true =&gt; minimal diameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classibex_1_1InvalidIntervalVectorOp.html" title="Base class for all exceptions raised by an operation on an interval vector.">InvalidIntervalVectorOp</a></td><td>if the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99f72908d03af672b9440a4d3bc691b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::max_diam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the maximal diameter among all the components. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classibex_1_1InvalidIntervalVectorOp.html" title="Base class for all exceptions raised by an operation on an interval vector.">InvalidIntervalVectorOp</a></td><td>if the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae95a05c46adc1018185433a19796ec89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::min_diam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the minimal diameter among all the components. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classibex_1_1InvalidIntervalVectorOp.html" title="Base class for all exceptions raised by an operation on an interval vector.">InvalidIntervalVectorOp</a></td><td>if the <a class="el" href="classibex_1_1IntervalVector.html" title="Vector of Intervals.">IntervalVector</a> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93843f0348a8f4ea1e6a77a1c40f8d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the volume of this interval vector. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classibex_1_1Return.html">Return</a> <code>POS_INFINITY</code> if the vector is unbounded and not flat. </dd>
<dd>
<a class="el" href="classibex_1_1Return.html">Return</a> 0 if the vector is flat and not unbounded. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the interval vector is both flat and unbounded, the result is undefined. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>#flat() </dd>
<dd>
#unbounded() </dd></dl>

</div>
</div>
<a class="anchor" id="ab08799e4c37b776dd27053e07dc99a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::perimeter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the perimeter of this interval vector. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classibex_1_1Return.html">Return</a> <code>POS_INFINITY</code> if unbounded. </dd></dl>

</div>
</div>
<a class="anchor" id="ae61cb5b387d46785b0d6bf37c2f24097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::maxdelta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> max of the delta, for x *this [deprecated]. </p>
<p>Deprecated. Kept for compatibility with ibex 1.xx. </p>

</div>
</div>
<a class="anchor" id="aadf5547726485722595aa9fd2ba069cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ibex::IntervalVector::rel_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the relative distance with x. </p>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$\displaystyle \max_{i=1..n} rel\_distance([this]_i, x_i)/diam([this]_i)$" src="form_9.png"/>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>#ibex::distance(const IntervalVector&amp; x1, const IntervalVector&amp; x2). </dd>
<dd>
<a class="el" href="classibex_1_1Interval.html#af3dd2ae96f2a1aaf629b6c314a274f4f" title="Relative Hausdorff distance between *this and x.">ibex::Interval::rel_distance(const Interval&amp; x) const</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="afd8e7614adde40bbc5ea75639495e972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ibex::IntervalVector::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> *&amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> *this \ y (set difference). </p>
<p>Store the difference under the form of a union of non-overlapping IntervalVectors into <em>result</em>, and return the size of the union.</p>
<p>If the difference is empty, <em>result</em> is an array of one element set to the empty box. It is <b>not</b> a zero-sized array containing no element. </p>

</div>
</div>
<a class="anchor" id="ab3d3b55c49cdaebc22ea0379f3aa03ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ibex::IntervalVector::complementary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a> *&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the complementary of *this. </p>
<p>Store the complementary under the form of a union of non-overlapping IntervalVectors, into <em>result</em>, and return the size of the union.</p>
<p>If (*this) is the empty set with n components, the complementary of (*this) is the n-dimensional box (-oo,oo)x...(-oo,oo).</p>
<p>If the complementary is empty, <em>result</em> is an array of one element set to the empty box. It is <b>not</b> a zero-sized array containing no element. </p>

</div>
</div>
<a class="anchor" id="ae17899009786991d85b5533ea69f8a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>,<a class="el" href="classibex_1_1IntervalVector.html">IntervalVector</a>&gt; ibex::IntervalVector::bisect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ratio</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bisect the box. </p>
<p>The box is bisected along the dimension <em>i</em> and with a ratio <em>ratio</em>. If (*this)[i] is the interval [a,a+d]: </p>
<ul>
<li>
The first box of the result is (*this)[0]x...x(*this)[i-1]x[a+ratio*d]x... </li>
<li>
The second box is (*this)[0]x...x(*this)[i-1]x[a+ratio*d,a+d]x... </li>
</ul>
<p>Default value for the ratio is 0.5. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0&lt;ratio&lt;1 </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f1958efa1b60636f1ee9dbebb22264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Vector.html">Vector</a> ibex::IntervalVector::random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> a random vector inside *this. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibex/ibex_IntervalVector.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 26 2013 10:27:36 for IBEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

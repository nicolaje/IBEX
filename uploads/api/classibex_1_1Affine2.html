<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>IBEX: ibex::Affine2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!!
-->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
function scroll(id) {
        var offset = $(id).offset().top; 
	$('html,body', window.parent.document).animate({scrollTop: offset}, 'fast');
}
</script>
</head>
<body>
<div id="top" style="background-image: url(../NCleanBlue/ibexbg960.png) no-repeat right;"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibex</b></li><li class="navelem"><a class="el" href="classibex_1_1Affine2.html">Affine2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classibex_1_1Affine2.html#pub-methods">Public Member Functions</a> &#124;
<a href="classibex_1_1Affine2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibex::Affine2 Class Reference<div class="ingroups"><a class="el" href="group__arithmetic.html">Interval Arithmetic</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Affine Arithmetic AF2.  
 <a href="classibex_1_1Affine2.html#details">More...</a></p>

<p><code>#include &lt;ibex_Affine2.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a25b32c541ffa53a9d6842279a8e80a32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b32c541ffa53a9d6842279a8e80a32"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a25b32c541ffa53a9d6842279a8e80a32">err</a> () const </td></tr>
<tr class="memdesc:a25b32c541ffa53a9d6842279a8e80a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">return _err <br/></td></tr>
<tr class="separator:a25b32c541ffa53a9d6842279a8e80a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19135048fc1d5d8997f3b7e8b41598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c19135048fc1d5d8997f3b7e8b41598"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a0c19135048fc1d5d8997f3b7e8b41598">Affine2</a> ()</td></tr>
<tr class="memdesc:a0c19135048fc1d5d8997f3b7e8b41598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty affine form. <br/></td></tr>
<tr class="separator:a0c19135048fc1d5d8997f3b7e8b41598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05ceb5493518bc1571d78537b69aaab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af05ceb5493518bc1571d78537b69aaab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#af05ceb5493518bc1571d78537b69aaab">Affine2</a> (const double d)</td></tr>
<tr class="memdesc:af05ceb5493518bc1571d78537b69aaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine form with n variables and initialized val[0] with d. <br/></td></tr>
<tr class="separator:af05ceb5493518bc1571d78537b69aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5295eb405476f17356c8bb2f78d38a15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5295eb405476f17356c8bb2f78d38a15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a5295eb405476f17356c8bb2f78d38a15">Affine2</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;<a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:a5295eb405476f17356c8bb2f78d38a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine form with n variables and initialized val[0] with itv. <br/></td></tr>
<tr class="separator:a5295eb405476f17356c8bb2f78d38a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dea9677b96e4322cc82dd4c4c3371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad80dea9677b96e4322cc82dd4c4c3371"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#ad80dea9677b96e4322cc82dd4c4c3371">Affine2</a> (int n, int m, const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;<a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:ad80dea9677b96e4322cc82dd4c4c3371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine form with n variables and initialized the m^th variable with itv. <br/></td></tr>
<tr class="separator:ad80dea9677b96e4322cc82dd4c4c3371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396ecdeedbfe09ffda70c0b9ee64d567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a396ecdeedbfe09ffda70c0b9ee64d567"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a396ecdeedbfe09ffda70c0b9ee64d567">Affine2</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a396ecdeedbfe09ffda70c0b9ee64d567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine form with n variables, initialized with x. <br/></td></tr>
<tr class="separator:a396ecdeedbfe09ffda70c0b9ee64d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068d82dc2026f86f84fc19f6dce70aca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068d82dc2026f86f84fc19f6dce70aca"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a068d82dc2026f86f84fc19f6dce70aca">~Affine2</a> ()</td></tr>
<tr class="memdesc:a068d82dc2026f86f84fc19f6dce70aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the affine form. <br/></td></tr>
<tr class="separator:a068d82dc2026f86f84fc19f6dce70aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e63e719f902ecf6f073c90bbd4eeab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a6e63e719f902ecf6f073c90bbd4eeab9">linChebyshev</a> (affine2_expr num, const <a class="el" href="classibex_1_1Interval.html">Interval</a> <a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:a6e63e719f902ecf6f073c90bbd4eeab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the min-range linearization of an unary operator  <a href="classibex_1_1Affine2.html#a6e63e719f902ecf6f073c90bbd4eeab9">More...</a><br/></td></tr>
<tr class="separator:a6e63e719f902ecf6f073c90bbd4eeab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcad068a3aabcb7c4d54a0672425f3d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcad068a3aabcb7c4d54a0672425f3d5"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#abcad068a3aabcb7c4d54a0672425f3d5">operator-</a> () const </td></tr>
<tr class="memdesc:abcad068a3aabcb7c4d54a0672425f3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> -*this. <br/></td></tr>
<tr class="separator:abcad068a3aabcb7c4d54a0672425f3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27b7a58442523f2db698b8f72136a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa27b7a58442523f2db698b8f72136a46"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aa27b7a58442523f2db698b8f72136a46">sqr</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> <a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:aa27b7a58442523f2db698b8f72136a46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> sqr(*this) <br/></td></tr>
<tr class="separator:aa27b7a58442523f2db698b8f72136a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70efcc79f6be833cd6b1d9f7f526143c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70efcc79f6be833cd6b1d9f7f526143c"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a70efcc79f6be833cd6b1d9f7f526143c">power</a> (int n, const <a class="el" href="classibex_1_1Interval.html">Interval</a> <a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:a70efcc79f6be833cd6b1d9f7f526143c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> pow(*this,n) <br/></td></tr>
<tr class="separator:a70efcc79f6be833cd6b1d9f7f526143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a80ef1dda38eed5ff6bd9bb602034"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1a80ef1dda38eed5ff6bd9bb602034"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a4d1a80ef1dda38eed5ff6bd9bb602034">operator==</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x) const </td></tr>
<tr class="memdesc:a4d1a80ef1dda38eed5ff6bd9bb602034"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are exactly the same intervals. <br/></td></tr>
<tr class="separator:a4d1a80ef1dda38eed5ff6bd9bb602034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af965ec49082cc1e8f5ba38d5b8819550"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af965ec49082cc1e8f5ba38d5b8819550"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#af965ec49082cc1e8f5ba38d5b8819550">operator==</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:af965ec49082cc1e8f5ba38d5b8819550"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are exactly the same intervals. <br/></td></tr>
<tr class="separator:af965ec49082cc1e8f5ba38d5b8819550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ba79ec72a03262a0eb5282d485c672"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84ba79ec72a03262a0eb5282d485c672"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a84ba79ec72a03262a0eb5282d485c672">operator!=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x) const </td></tr>
<tr class="memdesc:a84ba79ec72a03262a0eb5282d485c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are not exactly the same intervals. <br/></td></tr>
<tr class="separator:a84ba79ec72a03262a0eb5282d485c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2f97a2248631688a8a6055f80461b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d2f97a2248631688a8a6055f80461b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a90d2f97a2248631688a8a6055f80461b">operator!=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x) const </td></tr>
<tr class="memdesc:a90d2f97a2248631688a8a6055f80461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this and x are not exactly the same intervals. <br/></td></tr>
<tr class="separator:a90d2f97a2248631688a8a6055f80461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7564fb7457052d50b257ca93dc27505f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7564fb7457052d50b257ca93dc27505f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a7564fb7457052d50b257ca93dc27505f">set_empty</a> ()</td></tr>
<tr class="memdesc:a7564fb7457052d50b257ca93dc27505f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this interval to the empty set. <br/></td></tr>
<tr class="separator:a7564fb7457052d50b257ca93dc27505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f30f3d07c4bc8cf3b91ab71c38cd24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44f30f3d07c4bc8cf3b91ab71c38cd24"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a44f30f3d07c4bc8cf3b91ab71c38cd24">operator=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a44f30f3d07c4bc8cf3b91ab71c38cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to x. <br/></td></tr>
<tr class="separator:a44f30f3d07c4bc8cf3b91ab71c38cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e59b1d5fa6139de631b33d8eb5e68b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e59b1d5fa6139de631b33d8eb5e68b"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a94e59b1d5fa6139de631b33d8eb5e68b">operator=</a> (double x)</td></tr>
<tr class="memdesc:a94e59b1d5fa6139de631b33d8eb5e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to d. <br/></td></tr>
<tr class="separator:a94e59b1d5fa6139de631b33d8eb5e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdc9f73ee1badedec973c083560d23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bdc9f73ee1badedec973c083560d23b"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a0bdc9f73ee1badedec973c083560d23b">operator=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;<a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a>)</td></tr>
<tr class="memdesc:a0bdc9f73ee1badedec973c083560d23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to itv. <br/></td></tr>
<tr class="separator:a0bdc9f73ee1badedec973c083560d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9949a29ba6f2952044fc353dc4c2585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#ab9949a29ba6f2952044fc353dc4c2585">inflate</a> (double radd)</td></tr>
<tr class="memdesc:ab9949a29ba6f2952044fc353dc4c2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of *this and x.  <a href="classibex_1_1Affine2.html#ab9949a29ba6f2952044fc353dc4c2585">More...</a><br/></td></tr>
<tr class="separator:ab9949a29ba6f2952044fc353dc4c2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e029e5e9c36adae594b81653c9a1ae2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a8e029e5e9c36adae594b81653c9a1ae2">size</a> () const </td></tr>
<tr class="memdesc:a8e029e5e9c36adae594b81653c9a1ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number.  <a href="classibex_1_1Affine2.html#a8e029e5e9c36adae594b81653c9a1ae2">More...</a><br/></td></tr>
<tr class="separator:a8e029e5e9c36adae594b81653c9a1ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65ac00fae5ac390d8f6645efe7d7cf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac65ac00fae5ac390d8f6645efe7d7cf4"></a>
const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#ac65ac00fae5ac390d8f6645efe7d7cf4">itv</a> () const </td></tr>
<tr class="memdesc:ac65ac00fae5ac390d8f6645efe7d7cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of the affine form. <br/></td></tr>
<tr class="separator:ac65ac00fae5ac390d8f6645efe7d7cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb651e58ea1e3ccb2a9e96e5ecb767ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb651e58ea1e3ccb2a9e96e5ecb767ca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aeb651e58ea1e3ccb2a9e96e5ecb767ca">val</a> (int i) const </td></tr>
<tr class="memdesc:aeb651e58ea1e3ccb2a9e96e5ecb767ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">return _val[i] <br/></td></tr>
<tr class="separator:aeb651e58ea1e3ccb2a9e96e5ecb767ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47696a3f2bd9a880d31ffda2e63ef623"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47696a3f2bd9a880d31ffda2e63ef623"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a47696a3f2bd9a880d31ffda2e63ef623">is_actif</a> () const </td></tr>
<tr class="memdesc:a47696a3f2bd9a880d31ffda2e63ef623"><td class="mdescLeft">&#160;</td><td class="mdescRight">return 1 if the affine form is actif and valid <br/></td></tr>
<tr class="separator:a47696a3f2bd9a880d31ffda2e63ef623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63d119203cf6b231b48ad74539fbf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd63d119203cf6b231b48ad74539fbf0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#acd63d119203cf6b231b48ad74539fbf0">is_empty</a> () const </td></tr>
<tr class="memdesc:acd63d119203cf6b231b48ad74539fbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this is empty. <br/></td></tr>
<tr class="separator:acd63d119203cf6b231b48ad74539fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877be54b4d6b2ebb34c4af4de0aec673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877be54b4d6b2ebb34c4af4de0aec673"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a877be54b4d6b2ebb34c4af4de0aec673">is_degenerated</a> () const </td></tr>
<tr class="memdesc:a877be54b4d6b2ebb34c4af4de0aec673"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff *this is empty. <br/></td></tr>
<tr class="separator:a877be54b4d6b2ebb34c4af4de0aec673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d31252dbb2ddee28df518fc8b9724d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a2d31252dbb2ddee28df518fc8b9724d9">is_unbounded</a> () const </td></tr>
<tr class="memdesc:a2d31252dbb2ddee28df518fc8b9724d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if one bound of *this is infinite.  <a href="classibex_1_1Affine2.html#a2d31252dbb2ddee28df518fc8b9724d9">More...</a><br/></td></tr>
<tr class="separator:a2d31252dbb2ddee28df518fc8b9724d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce1a02dc5de5e09105632adf323f75d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce1a02dc5de5e09105632adf323f75d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a2ce1a02dc5de5e09105632adf323f75d">mid</a> () const </td></tr>
<tr class="memdesc:a2ce1a02dc5de5e09105632adf323f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the middle of *this <br/></td></tr>
<tr class="separator:a2ce1a02dc5de5e09105632adf323f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0065ca20e21b7f5c417af11cf484abe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0065ca20e21b7f5c417af11cf484abe5"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a0065ca20e21b7f5c417af11cf484abe5">operator+=</a> (double d)</td></tr>
<tr class="memdesc:a0065ca20e21b7f5c417af11cf484abe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>d</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a0065ca20e21b7f5c417af11cf484abe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b3d4b26ce90c7f5c43d535c31eb13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed4b3d4b26ce90c7f5c43d535c31eb13"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aed4b3d4b26ce90c7f5c43d535c31eb13">operator-=</a> (double d)</td></tr>
<tr class="memdesc:aed4b3d4b26ce90c7f5c43d535c31eb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <em>d</em> to *this and return the result. <br/></td></tr>
<tr class="separator:aed4b3d4b26ce90c7f5c43d535c31eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea729113f2a2ab228aab2fd331060571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea729113f2a2ab228aab2fd331060571"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aea729113f2a2ab228aab2fd331060571">operator*=</a> (double d)</td></tr>
<tr class="memdesc:aea729113f2a2ab228aab2fd331060571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply *this by <em>d</em> and return the result. <br/></td></tr>
<tr class="separator:aea729113f2a2ab228aab2fd331060571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0e426b3c48aa102111dd6a0fbdc200"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb0e426b3c48aa102111dd6a0fbdc200"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aeb0e426b3c48aa102111dd6a0fbdc200">operator/=</a> (double d)</td></tr>
<tr class="memdesc:aeb0e426b3c48aa102111dd6a0fbdc200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide *this by <em>d</em> and return the result. <br/></td></tr>
<tr class="separator:aeb0e426b3c48aa102111dd6a0fbdc200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56144ccf1fabff090702aa8b987e9a4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56144ccf1fabff090702aa8b987e9a4e"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a56144ccf1fabff090702aa8b987e9a4e">operator+=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a56144ccf1fabff090702aa8b987e9a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a56144ccf1fabff090702aa8b987e9a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419e5b0c5a7dfcac793b8ea1551bd281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419e5b0c5a7dfcac793b8ea1551bd281"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a419e5b0c5a7dfcac793b8ea1551bd281">operator-=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a419e5b0c5a7dfcac793b8ea1551bd281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a419e5b0c5a7dfcac793b8ea1551bd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56118ca36fec19ee3052d0788636755a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56118ca36fec19ee3052d0788636755a"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a56118ca36fec19ee3052d0788636755a">operator*=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a56118ca36fec19ee3052d0788636755a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply *this by <em>x</em> and return the result. <br/></td></tr>
<tr class="separator:a56118ca36fec19ee3052d0788636755a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6add8a7351eaf06ee8a92e7a16e19b36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6add8a7351eaf06ee8a92e7a16e19b36"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a6add8a7351eaf06ee8a92e7a16e19b36">operator/=</a> (const <a class="el" href="classibex_1_1Interval.html">Interval</a> &amp;x)</td></tr>
<tr class="memdesc:a6add8a7351eaf06ee8a92e7a16e19b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide *this by <em>x</em> and return the result. <br/></td></tr>
<tr class="separator:a6add8a7351eaf06ee8a92e7a16e19b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533fda111b9ac45a56583c0ac4a1e9a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a533fda111b9ac45a56583c0ac4a1e9a4"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#a533fda111b9ac45a56583c0ac4a1e9a4">operator+=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a533fda111b9ac45a56583c0ac4a1e9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:a533fda111b9ac45a56583c0ac4a1e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec399b24479cb7e84878e9b2b39c503f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec399b24479cb7e84878e9b2b39c503f"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aec399b24479cb7e84878e9b2b39c503f">operator-=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:aec399b24479cb7e84878e9b2b39c503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <em>x</em> to *this and return the result. <br/></td></tr>
<tr class="separator:aec399b24479cb7e84878e9b2b39c503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c27b9a6ff590bcf0afc1f813f4268"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb6c27b9a6ff590bcf0afc1f813f4268"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aeb6c27b9a6ff590bcf0afc1f813f4268">operator*=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:aeb6c27b9a6ff590bcf0afc1f813f4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply *this by <em>x</em> and return the result. <br/></td></tr>
<tr class="separator:aeb6c27b9a6ff590bcf0afc1f813f4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36bb8bc110122c73cb16010a5fae39c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36bb8bc110122c73cb16010a5fae39c"></a>
<a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2.html#aa36bb8bc110122c73cb16010a5fae39c">operator/=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:aa36bb8bc110122c73cb16010a5fae39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide *this by <em>x</em> and return the result. <br/></td></tr>
<tr class="separator:aa36bb8bc110122c73cb16010a5fae39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Affine Arithmetic AF2. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6e63e719f902ecf6f073c90bbd4eeab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2.html">Affine2</a>&amp; ibex::Affine2::linChebyshev </td>
          <td>(</td>
          <td class="paramtype">affine2_expr&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Interval.html">Interval</a>&#160;</td>
          <td class="paramname"><em>itv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the min-range linearization of an unary operator </p>
<p>compute the chebyshev linearization of an unary operator </p>

</div>
</div>
<a class="anchor" id="ab9949a29ba6f2952044fc353dc4c2585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp; ibex::Affine2::inflate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersection of *this and x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- the interval to compute the intersection with. Union of *this and I. </td></tr>
    <tr><td class="paramname">x</td><td>- the interval to compute the hull with. Add [-rad,+rad] to *this.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classibex_1_1Return.html">Return</a> a reference to *this. </p>

</div>
</div>
<a class="anchor" id="a8e029e5e9c36adae594b81653c9a1ae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ibex::Affine2::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number. </p>
<p>number of variable represented </p>

</div>
</div>
<a class="anchor" id="a2d31252dbb2ddee28df518fc8b9724d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Affine2::is_unbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if one bound of *this is infinite. </p>
<dl class="section note"><dt>Note</dt><dd>An empty affine form is always bounded. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibex/ibex_Affine2.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 26 2013 10:27:35 for IBEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

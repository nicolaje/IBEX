<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>IBEX: ibex::Affine2Matrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!!
-->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
function scroll(id) {
        var offset = $(id).offset().top; 
	$('html,body', window.parent.document).animate({scrollTop: offset}, 'fast');
}
</script>
</head>
<body>
<div id="top" style="background-image: url(../NCleanBlue/ibexbg960.png) no-repeat right;"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ibex</b></li><li class="navelem"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classibex_1_1Affine2Matrix.html#pub-methods">Public Member Functions</a> &#124;
<a href="classibex_1_1Affine2Matrix.html#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classibex_1_1Affine2Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ibex::Affine2Matrix Class Reference<div class="ingroups"><a class="el" href="group__arithmetic.html">Interval Arithmetic</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> matrix.  
 <a href="classibex_1_1Affine2Matrix.html#details">More...</a></p>

<p><code>#include &lt;ibex_Affine2Matrix.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a50abedbd8bab0ba028a89d09f4559cf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50abedbd8bab0ba028a89d09f4559cf8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a50abedbd8bab0ba028a89d09f4559cf8">Affine2Matrix</a> (int <a class="el" href="classibex_1_1Affine2Matrix.html#a04e50002038ca2e743bd93862bbc2056">nb_rows</a>, int <a class="el" href="classibex_1_1Affine2Matrix.html#ac8ac7ea83c3493ceca0a52c331164d98">nb_cols</a>)</td></tr>
<tr class="memdesc:a50abedbd8bab0ba028a89d09f4559cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a (nb_rows x nb_cols) matrix. <br/></td></tr>
<tr class="separator:a50abedbd8bab0ba028a89d09f4559cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf691f0487e06b3911783700b18c71d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cf691f0487e06b3911783700b18c71d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a9cf691f0487e06b3911783700b18c71d">Affine2Matrix</a> (int <a class="el" href="classibex_1_1Affine2Matrix.html#a04e50002038ca2e743bd93862bbc2056">nb_rows</a>, int <a class="el" href="classibex_1_1Affine2Matrix.html#ac8ac7ea83c3493ceca0a52c331164d98">nb_cols</a>, const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a9cf691f0487e06b3911783700b18c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a (nb_rows x nb_cols) matrix and initialize all the elements with x. <br/></td></tr>
<tr class="separator:a9cf691f0487e06b3911783700b18c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa3dcc9f8fdeb89e489a308883e26f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#aeaa3dcc9f8fdeb89e489a308883e26f4">Affine2Matrix</a> (const <a class="el" href="classibex_1_1IntervalMatrix.html">IntervalMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:aeaa3dcc9f8fdeb89e489a308883e26f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <em>x.size</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>x.nb_col*x</em>.nb_row with the [i][j] component initialized to <em>Affine2(m[i][j])</em>.  <a href="classibex_1_1Affine2Matrix.html#aeaa3dcc9f8fdeb89e489a308883e26f4">More...</a><br/></td></tr>
<tr class="separator:aeaa3dcc9f8fdeb89e489a308883e26f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd9847a59aa4b97fe9f864826a0d1b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd9847a59aa4b97fe9f864826a0d1b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#abfd9847a59aa4b97fe9f864826a0d1b2">Affine2Matrix</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;x)</td></tr>
<tr class="memdesc:abfd9847a59aa4b97fe9f864826a0d1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of x. <br/></td></tr>
<tr class="separator:abfd9847a59aa4b97fe9f864826a0d1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d13dc4ce2dd73ede3280e457a6115e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d13dc4ce2dd73ede3280e457a6115e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a1d13dc4ce2dd73ede3280e457a6115e2">Affine2Matrix</a> (const <a class="el" href="classibex_1_1Matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a1d13dc4ce2dd73ede3280e457a6115e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a degenerated <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> matrix. the [i][j] component initialized to <em>Affine2(m[i][j])</em>. <br/></td></tr>
<tr class="separator:a1d13dc4ce2dd73ede3280e457a6115e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8f92a8125ee8eb99b4b2be22a9db43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a6a8f92a8125ee8eb99b4b2be22a9db43">Affine2Matrix</a> (int m, int n, double x[][2])</td></tr>
<tr class="memdesc:a6a8f92a8125ee8eb99b4b2be22a9db43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> matrix from an array of doubles.  <a href="classibex_1_1Affine2Matrix.html#a6a8f92a8125ee8eb99b4b2be22a9db43">More...</a><br/></td></tr>
<tr class="separator:a6a8f92a8125ee8eb99b4b2be22a9db43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12074f151a1142ba0a964dd5014b4fa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12074f151a1142ba0a964dd5014b4fa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a12074f151a1142ba0a964dd5014b4fa0">~Affine2Matrix</a> ()</td></tr>
<tr class="memdesc:a12074f151a1142ba0a964dd5014b4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete *this. <br/></td></tr>
<tr class="separator:a12074f151a1142ba0a964dd5014b4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1fb73fbf01e17940745104fbcdbb8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee1fb73fbf01e17940745104fbcdbb8a"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#aee1fb73fbf01e17940745104fbcdbb8a">operator=</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;x)</td></tr>
<tr class="memdesc:aee1fb73fbf01e17940745104fbcdbb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set *this to m. <br/></td></tr>
<tr class="separator:aee1fb73fbf01e17940745104fbcdbb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aa0986b5698b27cefcbb5b83b5eadf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5aa0986b5698b27cefcbb5b83b5eadf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ad5aa0986b5698b27cefcbb5b83b5eadf">clear</a> ()</td></tr>
<tr class="memdesc:ad5aa0986b5698b27cefcbb5b83b5eadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to 0 (even if empty). <br/></td></tr>
<tr class="separator:ad5aa0986b5698b27cefcbb5b83b5eadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc2daf1b86302dd7661ce33c237ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a69bc2daf1b86302dd7661ce33c237ae7">init</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a69bc2daf1b86302dd7661ce33c237ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the elements to x (even if empty).  <a href="classibex_1_1Affine2Matrix.html#a69bc2daf1b86302dd7661ce33c237ae7">More...</a><br/></td></tr>
<tr class="separator:a69bc2daf1b86302dd7661ce33c237ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d71e1a2297d1fcb9fae6331bdaca23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#af5d71e1a2297d1fcb9fae6331bdaca23">operator==</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;m) const </td></tr>
<tr class="memdesc:af5d71e1a2297d1fcb9fae6331bdaca23"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the bounds of (*this) coincide with m.  <a href="classibex_1_1Affine2Matrix.html#af5d71e1a2297d1fcb9fae6331bdaca23">More...</a><br/></td></tr>
<tr class="separator:af5d71e1a2297d1fcb9fae6331bdaca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe029f018178c69bce959ce7a8d70da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fe029f018178c69bce959ce7a8d70da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a0fe029f018178c69bce959ce7a8d70da">operator!=</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;m) const </td></tr>
<tr class="memdesc:a0fe029f018178c69bce959ce7a8d70da"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if one bound of (*this) differs from m. <br/></td></tr>
<tr class="separator:a0fe029f018178c69bce959ce7a8d70da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6672ca9937feb5e3d48423cdcc490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1IntervalMatrix.html">IntervalMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a9de6672ca9937feb5e3d48423cdcc490">itv</a> () const </td></tr>
<tr class="memdesc:a9de6672ca9937feb5e3d48423cdcc490"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the <a class="el" href="classibex_1_1IntervalMatrix.html" title="Interval matrix.">IntervalMatrix</a> compose by the interval of each <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form.  <a href="classibex_1_1Affine2Matrix.html#a9de6672ca9937feb5e3d48423cdcc490">More...</a><br/></td></tr>
<tr class="separator:a9de6672ca9937feb5e3d48423cdcc490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33397fe46a945d0c25968a67856b921c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33397fe46a945d0c25968a67856b921c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a33397fe46a945d0c25968a67856b921c">resize</a> (int <a class="el" href="classibex_1_1Affine2Matrix.html#a04e50002038ca2e743bd93862bbc2056">nb_rows</a>, int <a class="el" href="classibex_1_1Affine2Matrix.html#ac8ac7ea83c3493ceca0a52c331164d98">nb_cols</a>)</td></tr>
<tr class="memdesc:a33397fe46a945d0c25968a67856b921c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the matrix. <br/></td></tr>
<tr class="separator:a33397fe46a945d0c25968a67856b921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac7ea83c3493ceca0a52c331164d98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ac7ea83c3493ceca0a52c331164d98"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ac8ac7ea83c3493ceca0a52c331164d98">nb_cols</a> () const </td></tr>
<tr class="memdesc:ac8ac7ea83c3493ceca0a52c331164d98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the number of columns. <br/></td></tr>
<tr class="separator:ac8ac7ea83c3493ceca0a52c331164d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e50002038ca2e743bd93862bbc2056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04e50002038ca2e743bd93862bbc2056"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a04e50002038ca2e743bd93862bbc2056">nb_rows</a> () const </td></tr>
<tr class="memdesc:a04e50002038ca2e743bd93862bbc2056"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the number of rows. <br/></td></tr>
<tr class="separator:a04e50002038ca2e743bd93862bbc2056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa125e28145277933b0bb3629cf4ec22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa125e28145277933b0bb3629cf4ec22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#afa125e28145277933b0bb3629cf4ec22">is_empty</a> () const </td></tr>
<tr class="memdesc:afa125e28145277933b0bb3629cf4ec22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> true iff this <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a> is empty. <br/></td></tr>
<tr class="separator:afa125e28145277933b0bb3629cf4ec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55aa73d1021ccb58226bb786105f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a4f55aa73d1021ccb58226bb786105f64">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a4f55aa73d1021ccb58226bb786105f64"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith row.  <a href="classibex_1_1Affine2Matrix.html#a4f55aa73d1021ccb58226bb786105f64">More...</a><br/></td></tr>
<tr class="separator:a4f55aa73d1021ccb58226bb786105f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca39bfa17444d31ded1d67f9671bfc1d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#aca39bfa17444d31ded1d67f9671bfc1d">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:aca39bfa17444d31ded1d67f9671bfc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a const reference to the ith row.  <a href="classibex_1_1Affine2Matrix.html#aca39bfa17444d31ded1d67f9671bfc1d">More...</a><br/></td></tr>
<tr class="separator:aca39bfa17444d31ded1d67f9671bfc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38096ae15e506e12ea08f9fb51438073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a38096ae15e506e12ea08f9fb51438073">set_empty</a> ()</td></tr>
<tr class="memdesc:a38096ae15e506e12ea08f9fb51438073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a> to the empty <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a>.  <a href="classibex_1_1Affine2Matrix.html#a38096ae15e506e12ea08f9fb51438073">More...</a><br/></td></tr>
<tr class="separator:a38096ae15e506e12ea08f9fb51438073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fb7b56667d6d133af64d99f8d93d68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48fb7b56667d6d133af64d99f8d93d68"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a48fb7b56667d6d133af64d99f8d93d68">submatrix</a> (int row_start_index, int row_end_index, int col_start_index, int col_end_index)</td></tr>
<tr class="memdesc:a48fb7b56667d6d133af64d99f8d93d68"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a submatrix. <br/></td></tr>
<tr class="separator:a48fb7b56667d6d133af64d99f8d93d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae144c932707693b7659c4f307d3a8ed0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae144c932707693b7659c4f307d3a8ed0"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ae144c932707693b7659c4f307d3a8ed0">transpose</a> () const </td></tr>
<tr class="memdesc:ae144c932707693b7659c4f307d3a8ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose of *this. <br/></td></tr>
<tr class="separator:ae144c932707693b7659c4f307d3a8ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9db1a3c0b30b68a2a12c1580e43c72a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ad9db1a3c0b30b68a2a12c1580e43c72a">row</a> (int i)</td></tr>
<tr class="memdesc:ad9db1a3c0b30b68a2a12c1580e43c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> the ith row.  <a href="classibex_1_1Affine2Matrix.html#ad9db1a3c0b30b68a2a12c1580e43c72a">More...</a><br/></td></tr>
<tr class="separator:ad9db1a3c0b30b68a2a12c1580e43c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa252fbc9d61d8f603a50b5795bec22d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#aa252fbc9d61d8f603a50b5795bec22d4">row</a> (int i) const </td></tr>
<tr class="memdesc:aa252fbc9d61d8f603a50b5795bec22d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a const reference to the ith row.  <a href="classibex_1_1Affine2Matrix.html#aa252fbc9d61d8f603a50b5795bec22d4">More...</a><br/></td></tr>
<tr class="separator:aa252fbc9d61d8f603a50b5795bec22d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d87e78cd4b039e0ed89c68f6be0a2a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d87e78cd4b039e0ed89c68f6be0a2a3"></a>
<a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a6d87e78cd4b039e0ed89c68f6be0a2a3">col</a> (int i) const </td></tr>
<tr class="memdesc:a6d87e78cd4b039e0ed89c68f6be0a2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a column. <br/></td></tr>
<tr class="separator:a6d87e78cd4b039e0ed89c68f6be0a2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b706a436ca18c98e18d052406c9c0d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b706a436ca18c98e18d052406c9c0d6"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a2b706a436ca18c98e18d052406c9c0d6">rows</a> (int start_index, int end_index)</td></tr>
<tr class="memdesc:a2b706a436ca18c98e18d052406c9c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a subset of rows. <br/></td></tr>
<tr class="separator:a2b706a436ca18c98e18d052406c9c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ddf57e408b3deba807b6fa387a03e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27ddf57e408b3deba807b6fa387a03e1"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a27ddf57e408b3deba807b6fa387a03e1">cols</a> (int start_index, int end_index)</td></tr>
<tr class="memdesc:a27ddf57e408b3deba807b6fa387a03e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classibex_1_1Return.html">Return</a> a subset of columns. <br/></td></tr>
<tr class="separator:a27ddf57e408b3deba807b6fa387a03e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab626833a639bcfdea0b7bbbd0ab7e802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab626833a639bcfdea0b7bbbd0ab7e802"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ab626833a639bcfdea0b7bbbd0ab7e802">set_row</a> (int <a class="el" href="classibex_1_1Affine2Matrix.html#ad9db1a3c0b30b68a2a12c1580e43c72a">row</a>, const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;v)</td></tr>
<tr class="memdesc:ab626833a639bcfdea0b7bbbd0ab7e802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a row. <br/></td></tr>
<tr class="separator:ab626833a639bcfdea0b7bbbd0ab7e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ebcf206aafcc3fa623b14151460e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8ebcf206aafcc3fa623b14151460e8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#ab8ebcf206aafcc3fa623b14151460e8a">set_col</a> (int <a class="el" href="classibex_1_1Affine2Matrix.html#a6d87e78cd4b039e0ed89c68f6be0a2a3">col</a>, const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp;v)</td></tr>
<tr class="memdesc:ab8ebcf206aafcc3fa623b14151460e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a column. <br/></td></tr>
<tr class="separator:ab8ebcf206aafcc3fa623b14151460e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c88bfa830953e3ab2d10d08ecb8dcfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c88bfa830953e3ab2d10d08ecb8dcfb"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a7c88bfa830953e3ab2d10d08ecb8dcfb">operator+=</a> (const <a class="el" href="classibex_1_1Matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a7c88bfa830953e3ab2d10d08ecb8dcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=m. <br/></td></tr>
<tr class="separator:a7c88bfa830953e3ab2d10d08ecb8dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e0a667829e3ceed7ffcbb694c40d91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01e0a667829e3ceed7ffcbb694c40d91"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a01e0a667829e3ceed7ffcbb694c40d91">operator+=</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a01e0a667829e3ceed7ffcbb694c40d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)+=m. <br/></td></tr>
<tr class="separator:a01e0a667829e3ceed7ffcbb694c40d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31098b8896ea0fdc81ef6436b5c6a97d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31098b8896ea0fdc81ef6436b5c6a97d"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a31098b8896ea0fdc81ef6436b5c6a97d">operator-=</a> (const <a class="el" href="classibex_1_1Matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a31098b8896ea0fdc81ef6436b5c6a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=m. <br/></td></tr>
<tr class="separator:a31098b8896ea0fdc81ef6436b5c6a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ce978460d682bb811e2f438ff3c775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a05ce978460d682bb811e2f438ff3c775">operator-=</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a05ce978460d682bb811e2f438ff3c775"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)-=m.  <a href="classibex_1_1Affine2Matrix.html#a05ce978460d682bb811e2f438ff3c775">More...</a><br/></td></tr>
<tr class="separator:a05ce978460d682bb811e2f438ff3c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc343bcfde8ff660d98eada1c9bf4f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#afc343bcfde8ff660d98eada1c9bf4f74">inflate</a> (double rad)</td></tr>
<tr class="memdesc:afc343bcfde8ff660d98eada1c9bf4f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add [-rad,+rad] to all the components of *this.  <a href="classibex_1_1Affine2Matrix.html#afc343bcfde8ff660d98eada1c9bf4f74">More...</a><br/></td></tr>
<tr class="separator:afc343bcfde8ff660d98eada1c9bf4f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0db80b8fbc01887d01ec897a5d87f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c0db80b8fbc01887d01ec897a5d87f3"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a6c0db80b8fbc01887d01ec897a5d87f3">operator*=</a> (double x)</td></tr>
<tr class="memdesc:a6c0db80b8fbc01887d01ec897a5d87f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)=x * *(this). <br/></td></tr>
<tr class="separator:a6c0db80b8fbc01887d01ec897a5d87f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5ef5ffa5f9e48b0813399c95bcaa35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d5ef5ffa5f9e48b0813399c95bcaa35"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a6d5ef5ffa5f9e48b0813399c95bcaa35">operator*=</a> (const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;x)</td></tr>
<tr class="memdesc:a6d5ef5ffa5f9e48b0813399c95bcaa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">(*this)=x * *(this). <br/></td></tr>
<tr class="separator:a6d5ef5ffa5f9e48b0813399c95bcaa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f99c96e4ef3c9c6c8012b2b6bd89c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f99c96e4ef3c9c6c8012b2b6bd89c94"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a9f99c96e4ef3c9c6c8012b2b6bd89c94">operator*=</a> (const <a class="el" href="classibex_1_1Matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a9f99c96e4ef3c9c6c8012b2b6bd89c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)</em>=m. <br/></td></tr>
<tr class="separator:a9f99c96e4ef3c9c6c8012b2b6bd89c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ae0016447e0afb837efa4b3c295529"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15ae0016447e0afb837efa4b3c295529"></a>
<a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a15ae0016447e0afb837efa4b3c295529">operator*=</a> (const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a15ae0016447e0afb837efa4b3c295529"><td class="mdescLeft">&#160;</td><td class="mdescRight">(<em>this)</em>=m. <br/></td></tr>
<tr class="separator:a15ae0016447e0afb837efa4b3c295529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a92f1a9bbce784a5f813adbf2a07e04f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classibex_1_1Affine2Matrix.html#a92f1a9bbce784a5f813adbf2a07e04f6">empty</a> (int m, int n)</td></tr>
<tr class="memdesc:a92f1a9bbce784a5f813adbf2a07e04f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mxn empty matrix.  <a href="classibex_1_1Affine2Matrix.html#a92f1a9bbce784a5f813adbf2a07e04f6">More...</a><br/></td></tr>
<tr class="separator:a92f1a9bbce784a5f813adbf2a07e04f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> matrix. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeaa3dcc9f8fdeb89e489a308883e26f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Matrix::Affine2Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1IntervalMatrix.html">IntervalMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create <em>x.size</em> <a class="el" href="classibex_1_1Affine2Vector.html" title="Vector of Affine2 form.">Affine2Vector</a> of dimension <em>x.nb_col*x</em>.nb_row with the [i][j] component initialized to <em>Affine2(m[i][j])</em>. </p>
<p>It is too difficult to know the size of each AF2. So we let the user do what exactly he want to do. </p>

</div>
</div>
<a class="anchor" id="a6a8f92a8125ee8eb99b4b2be22a9db43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibex::Affine2Matrix::Affine2Matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>[][2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> matrix from an array of doubles. </p>
<p>Create the <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a>: <br/>
 [x[0][0],x[0][1]] ; ... ; [x[n-1][0], x[n-1][1]] <br/>
 [x[n][0],x[n][1]] ; ... ; [x[2n-1][0],x[2n-1][1]] <br/>
 ... <br/>
 [x[(m-1)n][0],x[n][1]] ; ... ; [x[mn-1][0],x[2n-1][1]] <br/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>an (mxn)x2 array of doubles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>m&gt;0, n&gt;0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92f1a9bbce784a5f813adbf2a07e04f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> ibex::Affine2Matrix::empty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a mxn empty matrix. </p>
<p>Create an empty <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a> of dimension <em>n</em> x <em>m</em> (all the components being empty Affine2s)</p>
<dl class="section pre"><dt>Precondition</dt><dd>m&gt;0, n&gt;0 </dd></dl>

</div>
</div>
<a class="anchor" id="a69bc2daf1b86302dd7661ce33c237ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Matrix::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the elements to x (even if empty). </p>
<dl class="section note"><dt>Note</dt><dd>Emptiness is "overridden". </dd></dl>

</div>
</div>
<a class="anchor" id="af5d71e1a2297d1fcb9fae6331bdaca23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ibex::Affine2Matrix::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the bounds of (*this) coincide with m. </p>
<p>If the two matrices are empty and with the same dimensions then they are considered as equal. </p>

</div>
</div>
<a class="anchor" id="a9de6672ca9937feb5e3d48423cdcc490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1IntervalMatrix.html">IntervalMatrix</a> ibex::Affine2Matrix::itv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the <a class="el" href="classibex_1_1IntervalMatrix.html" title="Interval matrix.">IntervalMatrix</a> compose by the interval of each <a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> form. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(*this) must be nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a4f55aa73d1021ccb58226bb786105f64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp; ibex::Affine2Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith row. </p>
<p>Use (*this)[i][j] to get a reference to the element M(i,j). </p>

</div>
</div>
<a class="anchor" id="aca39bfa17444d31ded1d67f9671bfc1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp; ibex::Affine2Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> a const reference to the ith row. </p>
<p>Use (*this)[i][j] to get a reference to the element M(i,j). </p>

</div>
</div>
<a class="anchor" id="a38096ae15e506e12ea08f9fb51438073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ibex::Affine2Matrix::set_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a> to the empty <a class="el" href="classibex_1_1Affine2Matrix.html" title="Affine2 matrix.">Affine2Matrix</a>. </p>
<p>The dimensions remain the same. </p>

</div>
</div>
<a class="anchor" id="ad9db1a3c0b30b68a2a12c1580e43c72a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp; ibex::Affine2Matrix::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> the ith row. </p>
<p>Equivalent to (*this)[i. </p>

</div>
</div>
<a class="anchor" id="aa252fbc9d61d8f603a50b5795bec22d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classibex_1_1Affine2Vector.html">Affine2Vector</a> &amp; ibex::Affine2Matrix::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classibex_1_1Return.html">Return</a> a const reference to the ith row. </p>
<p>Equivalent to (*this)[i. </p>

</div>
</div>
<a class="anchor" id="a05ce978460d682bb811e2f438ff3c775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&amp; ibex::Affine2Matrix::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(*this)-=m. </p>
<p><a class="el" href="classibex_1_1Affine2.html" title="Affine Arithmetic AF2.">Affine2</a> </p>

</div>
</div>
<a class="anchor" id="afc343bcfde8ff660d98eada1c9bf4f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classibex_1_1Affine2Matrix.html">Affine2Matrix</a>&amp; ibex::Affine2Matrix::inflate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add [-rad,+rad] to all the components of *this. </p>
<dl class="section return"><dt>Returns</dt><dd>*this. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ibex/ibex_Affine2Matrix.h</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 26 2013 10:27:35 for IBEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

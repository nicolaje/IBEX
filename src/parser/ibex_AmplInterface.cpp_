//============================================================================
//                                  I B E X
// File        : ibex_AmplInterface.cpp Adapted from CouenneAmplInterface
// Author      : Jordan Ninin
// License     : See the LICENSE file
// Created     : Nov 5, 2013
// Last Update : Nov 5, 2013
//============================================================================

#include "ibex_AmplInterface.h_"

#include "solvers/asl.h"
#include "solvers/nlp.h"
#include "solvers/getstub.h"
#include "solvers/opcode.hd"
#include <stdint.h>

// get ASL op. code relative to function pointer passed as parameter
int getOperator (efunc *);

#define OBJ_DE    ((const ASL_fg *) asl) -> I.obj_de_
#define VAR_E     ((const ASL_fg *) asl) -> I.var_e_
#define CON_DE    ((const ASL_fg *) asl) -> I.con_de_
#define OBJ_sense ((const ASL_fg *) asl) -> i.objtype_
#define CEXPS1 ((const ASL_fg *) asl) -> I.cexps1_
#define CEXPS ((const ASL_fg *) asl) -> I.cexps_

#include "solvers/r_opn.hd" /* for N_OPS */

static fint timing = 0;

static
keyword keywds[] = { // must be alphabetical
		KW(const_cast<char*>("timing"), L_val, &timing, const_cast<char*>("display timings for the run")),
};

static
Option_Info Oinfo = { const_cast<char*>("testampl"), const_cast<char*>("ANALYSIS TEST"),
		const_cast<char*>("concert_options"), keywds, nkeywds, 0, const_cast<char*>("ANALYSIS TEST") };


// (C++) code starts here ///////////////////////////////////////////////////////////////////////////

namespace ibex {

AmplInterface::AmplInterface(std::string nlfile) :
			_problem(NULL),	_bound_init(NULL), asl(NULL), _nlfile(nlfile), _x(NULL){

}

AmplInterface::~AmplInterface() {
	delete _problem;
	delete _bound_init;
	delete _x;

	if (asl) {
		ASL_free(&asl);
	}
}

// create an AMPL problem by using ASL interface to the .nl file
System AmplInterface::getSystem() {
	if (_problem)
		return System(*_problem);

	if (!readASLfg())
		return NULL;

	_problem = new SystemFactory();

	if (!readnl()) {
		delete _problem;
		_problem = NULL;
		return NULL;
	}

	return System(*_problem);
}




// Reads a NLP from an AMPL .nl file through the ASL methods
bool AmplInterface::readASLfg() {
	assert(asl == NULL);


	if (_nlfile == "")
		return false;

	char** argv = new char*[3];
	argv[0] = const_cast<char*>("dummy");
	argv[1] = strdup(_nlfile.c_str());
	argv[2] = NULL;

	// Create the ASL structure
	asl = (ASL*) ASL_alloc (ASL_read_fg);

	char* stub = getstub (&argv, &Oinfo);

	// Although very intuitive, we shall explain why the second argument
	// is passed with a minus sign: it is to tell the ASL to retrieve
	// the nonlinear information too.
	FILE* nl = jac0dim (stub, - (fint) strlen (stub));

	// Set options in the asl structure
	want_xpi0 = 1 | 2;  // allocate initial values for primal and dual if available
	obj_no = 0;         // always want to work with the first (and only?) objective

	// read the rest of the nl file
	fg_read (nl, ASL_return_read_err | ASL_findgroups);

	//FIXME freeing argv and argv[1] gives segfault !!!
	//  free(argv[1]);
	//  delete[] argv;

	return true;
}




// Reads a NLP from an AMPL .nl file through the ASL methods
bool AmplInterface::readnl() {


	if (!_problem) {return false;}

	_x =new Variable(n_var);
	_bound_init = new IntervalVector(n_var, Interval::ALL_REALS);
	_problem->add_var(*_x);


	// Each has a linear and a nonlinear part (thanks to Dominique
	// Orban: http://www.gerad.ca/~orban/drampl/def-vars.html)

	try {

		// objective functions /////////////////////////////////////////////////////////////
		if (n_obj>1) {ibexerror("too much objective function"); return false;}

		for (int i = 0; i < n_obj; i++) {

			ExprNode& body = nl2expr (OBJ_DE [i] . e);

			// 3rd/ASL/solvers/asl.h, line 336: 0 is minimization, 1 is maximization
			if (OBJ_sense [i] == 0) {
				_problem->add_goal(body);
			} else {
				_problem->add_goal(-body);
			}
		}


		// constraints ///////////////////////////////////////////////////////////////////

		for (int i = 0; i < n_con; i++) {

			CmpOp sign;
			double lb, ub;

			/* LUrhs is the constraint lower bound if Urhsx!=0, and the constraint lower and upper bound if Uvx == 0 */
			if (Urhsx) {
				lb = LUrhs [i];
				ub = Urhsx [i];
			} else {
				int j = 2*i;
				lb = LUrhs [j];
				ub = LUrhs [j+1];
			}

			// set constraint sign
			if (negInfinity < lb)
				if (ub < Infinity) {sign = CmpOp::EQ; }
				else                sign = GEQ;
			else                    sign = LEQ;

			ExprNode& body = nl2expr (CON_DE [i] . e);

			// add them (and set lower-upper bound)
			switch (sign) {

			case  CmpOp::EQ :  _problem->add_ctr(ExprCtr(body-Interval(lb,ub),CmpOp::EQ)); break;
			case  CmpOp::LEQ:  _problem->add_ctr(ExprCtr(body-ub,CmpOp::LEQ)); break;
			case  CmpOp::GEQ:  _problem->add_ctr(ExprCtr(body-lb,CmpOp::GEQ)); break;
			default: ibexerror("Error: could not recognize a constraint\n"); return false;
			}
		}

	} catch (...) {
		return false;
	}


	// lower and upper bounds ///////////////////////////////////////////////////////////////

	if (LUv) {
		real *Uvx_copy = Uvx;
		/* LUv is the variable lower bound if Uvx!=0, and the variable lower and upper bound if Uvx == 0 */
		if (!Uvx_copy)
			for (register int i=0; i<n_var; i++) {

				register int j = 2*i;
				(*_bound_init)[i] = Interval(  ((LUv[j]   <= NEG_INFINITY) ? NEG_INFINITY : LUv[j]  ),
											((LUv[j+1] >= POS_INFINITY) ? POS_INFINITY : LUv[j+1]) );
			}
		else
			for (register int i=n_var; i--;) {
				(*_bound_init)[i] = Interval(	(LUv [i]      <= NEG_INFINITY ? NEG_INFINITY : LUv[i]     ),
											(Uvx_copy [i] >= POS_INFINITY ? POS_INFINITY : Uvx_copy[i]) );
			}

	} // else it is [-oo,+oo]


	return true;
}

// converts an AMPL expression (sub)tree into an expression* (sub)tree
// thank to Dominique Orban for the explication of the DAG inside AMPL:
// http://www.gerad.ca/~orban/drampl/dag.html
ExprNode& AmplInterface::nl2expr(expr *e) {

	switch (getOperator (e -> op)) {

	case OPPLUS:  return   ((nl2expr (e -> L.e)) + (nl2expr (e -> R.e)));
	case OPMINUS: return   ((nl2expr (e -> L.e)) - (nl2expr (e -> R.e)));
	case OPMULT:  return   ((nl2expr (e -> L.e)) * (nl2expr (e -> R.e)));
	case OPDIV:   return   ((nl2expr (e -> L.e)) / (nl2expr (e -> R.e)));
	//case OPREM:   notimpl ("remainder");
	case OPPOW:   return   pow(nl2expr (e -> L.e), nl2expr (e -> R.e));
	//case OPLESS:  notimpl ("less");
	case MINLIST: {
		expr **ep = e->L.ep;
		const ExprNode* ee=&(nl2expr (*ep));
		while (ep < e->R.ep) {
			ee = & (min(*ee , nl2expr (*ep)));
			ep++;
		}
		return ee;
	}
	case MAXLIST:  {
		expr **ep = e->L.ep;
		const ExprNode* ee=&(nl2expr (*ep));
		while (ep < e->R.ep) {
			ee = & (max(*ee , nl2expr (*ep)));
			ep++;
		}
		return ee;
	}
	//case FLOOR:   notimpl ("floor");
	//case CEIL:    notimpl ("ceil");
	case ABS:     return (abs(nl2expr (e -> L.e)));
	case OPUMINUS:return (-(nl2expr (e -> L.e)));
	//case OPIFnl:  return (chi(nl2expr(????)))

	case OP_tanh: return tanh(nl2expr (e->L.e));

	case OP_tan:   return tan(nl2expr (e->L.e));
	case OP_sqrt:  return sqrt(nl2expr (e -> L.e));
	case OP_sinh:  return sinh(nl2expr (e -> L.e));
	case OP_sin:   return sin(nl2expr (e -> L.e));
	case OP_log10: return ((ExprConstant::new_scalar(1.0/log(Interval(10.0)))) * log(nl2expr (e -> L.e)));
	case OP_log:   return log(nl2expr (e -> L.e));
	case OP_exp:   return exp(nl2expr (e -> L.e));
	case OP_cosh:  return cosh(nl2expr (e->L.e));
	case OP_cos:   return cos(nl2expr (e -> L.e));
	//case OP_atanh: notimpl ("atanh");
	case OP_atan2: return atan2(nl2expr (e -> L.e), nl2expr (e -> R.e));
	case OP_atan:  return tan(nl2expr (e -> L.e));
	//case OP_asinh: notimpl ("asinh");
	case OP_asin:  return asin(nl2expr (e -> L.e));
	//case OP_acosh: notimpl ("acosh");
	case OP_acos:  return acos(nl2expr (e -> L.e));

	case OPSUMLIST: {
		expr **ep = e->L.ep;
		const ExprNode* ee=&(nl2expr (*ep));
		while (ep < e->R.ep) {
			ee = & (*ee + nl2expr (*ep));
			ep++;
		}
		return ee;
	}
	//case OPintDIV: notimpl ("intdiv");
	//case OPprecision: notimpl ("precision");
	//case OPround:  notimpl ("round");
	//case OPtrunc:  notimpl ("trunc");

	case OP1POW: return pow( (nl2expr (e -> L.e)), ExprConstant::new_scalar(((expr_n *)e->R.e)->v));
	case OP2POW: return sqr( nl2expr (e -> L.e));
	case OPCPOW: return pow(ExprConstant::new_scalar(((expr_n *)e->L.e)->v), nl2expr (e -> R.e));
	//case OPFUNCALL: notimpl ("function call");
	case OPNUM:     return (ExprConstant::new_scalar(((expr_n *)e)->v));
	//case OPPLTERM:  notimpl ("plterm");
	//case OPIFSYM:   notimpl ("ifsym");
	//case OPHOL:     notimpl ("hol");
	case OPVARVAL:  {
////////////////////////////////////////////////////////////////////// TODO a FINIR

		int j = ((expr_v *) e) -> a;

		if (j<n_var) {
			return (*_x)[j];

		}
		else if (j < n_var + como + comc + comb + como1 + comc1) {// common expression | defined variable
			// use base pointer otherwise the .a field returns an awkward, out-of-bound index

		     // This is a common expression. Find pointer to its root.

		     j = j - n_var;
		     cexp *common;
		     if( j < ncom0 )
		    	 common = CEXPS + j;
		     else
		    	 common = CEXPS1 - ncom0 +j ;

		     ExprNode& body = nl2expr (common->e);

		     int nlin = common->nlin; // Number of linear terms
		     if( nlin > 0 ) {
		    	 linpart * L = common->L;
		    	 for(int i = 1; i < nlin; i++ ) {

		    		 int coeff = L [i]. fac;
		    		 int index = ((uintptr_t) (L [j].v.rp) - (uintptr_t) VAR_E) / sizeof (expr_v);
		    		 body = &(body +coeff * (*_x)[index]);
		    	 }
		     }
		     return body;
		}
		else {
			ibexerror( "Error: unknown variable x_"+ j +"\n");
			throw -1;
		}

	}

	default:
		ibexerror( "ERROR: unknown operator (address " + Intcast (e -> op) + "), aborting.\n");
		throw -2;
	}

	return ExprConstant::new_scalar(0.);
}

}

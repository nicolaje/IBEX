//============================================================================
//                                  I B E X                                   
// File        : ibex_ParserConstant.cpp
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : May 25, 2012
// Last Update : May 25, 2012
//============================================================================

#include "ibex_ParserExpr.h"
#include "ibex_Expr.h"
#include <math.h>

using namespace std;

extern void ibexerror (const std::string&);

namespace ibex {
namespace parser {

typedef enum { _int_, _double_, _itv_, _int_vec_, _double_vec_, _itv_vec_, _itv_mat_ } csttype;

static csttype common_type(const P_ExprConstant& c1,const P_ExprConstant& c2) {
	switch (c1.type) {
	case _int_ :
		switch (c2.type) {
		case _int_     : return _int_;
		case _double_  : return _double_;
		case _itv_     : return _itv_;
		default        : ibexerror("Mismatched operand types (integer and vector/matrix)");
						 return _int_; // (ignored)
		}
	case _double_ :
		switch (c2.type) {
		case _int_     :
		case _double_  : return _double_;
		case _itv_     : return _itv_;
		default        : ibexerror("Mismatched operand types (double and vector/matrix)");
		return _int_; // (ignored)
		}
	case _itv_ :
		switch (c2.type) {
		case _int_     :
		case _double_  :
		case _itv_     : return _itv_;
		default        : ibexerror("Mismatched operand types (Interval and vector/matrix)");
		return _int_; // (ignored)
		}
	case _int_vec_ :
		switch (c2.type) {
		case _int_vec_  : return _int_vec_;
		case _double_vec_ : return _double_vec_;
		case _itv_vec_  : return _itv_vec_;
		case _itv_mat_  : ibexerror("Mismatched operand types (vector and matrix)");
						  return _int_; // (ignored)
		default         : ibexerror("Mismatched operand types (vector and scalar)");
						  return _int_; // (ignored)
		}
	case _double_vec_ :
		switch (c2.type) {
		case _int_vec_  :
		case _double_vec_ : return _double_vec_;
		case _itv_vec_  : return _itv_vec_;
		case _itv_mat_  : ibexerror("Mismatched operand types (vector and matrix)");
				          return _int_; // (ignored)
		default         : ibexerror("Mismatched operand types (vector and scalar)");
			  	  	      return _int_; // (ignored)
		}
	case _itv_vec_ :
		switch (c2.type) {
		case _int_vec_  :
		case _double_vec_ :
		case _itv_vec_  : return _itv_vec_;
		case _itv_mat_  : ibexerror("Mismatched operand types (vector and matrix)");
						  return _int_; // (ignored)
		default         : ibexerror("Mismatched operand types (vector and scalar)");
						  return _int_; // (ignored)
		}

	default :
		switch (c2.type) {
		case _itv_mat_ : return _itv_mat_;
		default        : ibexerror("Mismatched operand types (matrix and scalar/vector)");
					     return _int_; // (ignored)
		}
	}
}

static csttype array_type(const vector<P_ExprConstant>& vec) {
	int elem_type = vec[0].type;

	/* first loop: determine type of the vector */
	for (unsigned int i=1; i<vec.size(); i++) {
		switch (common_type(vec[i-1],vec[i])) { // will check that scalar & non-scalar are not mixed
		case _int_     : break;
		case _double_  : if (elem_type==_int_) elem_type=_double_; break;
		case _itv_     : elem_type=_itv_; break;
		case _int_vec_ : break;
		case _double_vec_: if (elem_type==_int_vec_) elem_type=_double_vec_; break;
		case _itv_vec_ : elem_type = _itv_vec_; break;
		default        : ibexerror("Cannot build 3D constant vectors"); break;
		}
	}

	switch(elem_type) {
	case _int_    : return _int_vec_;
	case _double_ : return _double_vec_;
	case _itv_    : return _itv_vec_;
	default       : return _itv_mat_;
	}
}

P_ExprConstant::P_ExprConstant(int n) : ExprNode(0,1,Dim(0,0,0)), type(_int_), n(n), v(0), M(0,0) { }

P_ExprConstant::P_ExprConstant(double r) :  ExprNode(0,1,Dim(0,0,0)), type(_double_), r(r), v(0), M(0,0) { }

P_ExprConstant::P_ExprConstant(const Interval& x) :  ExprNode(0,1,Dim(0,0,0)), type(_itv_), x(x), v(0), M(0,0) { }

P_ExprConstant::P_ExprConstant(const vector<P_ExprConstant>& vec) :  ExprNode(0,1,Dim(0,0,0)), type(array_type(vec)), v(0), M(0,0) {

	int size=vec.size();

	switch(type) {
	case _int_vec_  :
	case _double_vec_ :
	case _itv_vec_  :
		v.resize(size);
		for (int i=0; i<size; i++) v[i]=vec[i]._2itv();
		break;
	default     :
		int m=vec[0]._2itvv().size();
		M.resize(size,m);
		for (int i=0; i<size; i++) {
			IntervalVector x=vec[i]._2itvv();
			if (x.size()!=m) ibexerror("Cannot initialize a matrix constant with vectors of different size");
			M.set_row(i,x);
		}
		break;
	}
}

P_ExprConstant::P_ExprConstant(const IntervalVector& v) : type(_itv_vec_), v(v), M(0,0) { }

P_ExprConstant::P_ExprConstant(const IntervalMatrix& M) : type(_itv_mat_), v(0), M(M) { }

P_ExprConstant::~P_ExprConstant() { }

bool P_ExprConstant::is_zero() const {
	switch (type) {
	case _int_  : return n==0;
	case _double_ : return r==0.0;
	case _itv_  : return x.lb()==0 && x.ub()==0;
	case _int_vec_  :
	case _double_vec_ :
	case _itv_vec_  :
		for (int i=1; i<=v.size(); i++)
			if (v[i].lb()!=0 || v[i].ub()!=0) return false;
		return true;
	default :
		for (int i=1; i<=M.nb_rows(); i++)
			for (int j=1; j<=M.nb_cols(); j++)
				if (M[i][j].lb()!=0 || M[i][j].ub()!=0) return false;
		return true;
	}
}

bool P_ExprConstant::is_scalar() const {
	return (type==_int_ || type==_double_ || type==_itv_);
}

/*
P_ExprConstant& P_ExprConstant::operator=(const P_ExprConstant& c) {
	type=c.type;
	n=c.n;
	r=c.r;
	x=c.x;
	v.resize(c.v.size());
	v=c.v;
	M.resize(c.M.nb_rows(),c.M.nb_cols());
	M=c.M;
	return *this;
}*/

P_ExprConstant P_ExprConstant::operator[](int i) const {

	/* check that this constant is a vector */
	if (is_scalar()) ibexerror("Constant with too many indexes");

	/* check dimensions */
	switch(type) {
	case _int_vec_    :
	case _double_vec_ :
	case _itv_vec_    : if (i>v.size()) ibexerror("Constant index out of bounds"); break;
	default           : if (i>M.nb_rows()) ibexerror("Constant index out of bounds"); break;
	}

	/* return the ith element */
	switch(type) {
	case _int_vec_    : return P_ExprConstant((int) v[i].mid());
	case _double_vec_ : return P_ExprConstant(v[i].mid());
	case _itv_vec_    : return P_ExprConstant(v[i]);
	default           : return P_ExprConstant(M.row(i));
	}
}

ostream& operator<<(ostream& os, const P_ExprConstant& c) {
	// return os << (const P_Expr&) c;
	return os;
}

int P_ExprConstant::_2int() const {
	switch (type) {
	case _int_ : return n;
	default    : ibexerror("Integer expected"); return -1;
	}
}

double P_ExprConstant::_2double() const {
	switch (type) {
	case _int_    : return n;
	case _double_ : return r;
	default       : ibexerror("double expected (not interval)"); return -1;
	}
}

Interval P_ExprConstant::_2itv() const {
	switch (type) {
	case _int_    : return Interval(n,n);
	case _double_ : return Interval(r,r);
	case _itv_    : return x;
	default       : ibexerror("interval expected (not vector nor matrix)"); return -1;
	}
}

IntervalVector P_ExprConstant::_2itvv() const {
	switch (type) {
	case _int_vec_    :
	case _double_vec_ :
	case _itv_vec_    : return v;
	default           : ibexerror("interval vector expected"); return IntervalVector(0);
	}
}

IntervalMatrix P_ExprConstant::_2itvM() const {
	switch (type) {
	case _itv_mat_ : return M;
	default        : ibexerror("interval matrix expected"); return M; // (ignored)
	}
}

P_ExprConstant transpose(const P_ExprConstant& c) {
	switch (c.type) {
	case _itv_mat_ : return c.M.transpose();
	default        : ibexerror("interval matrix expected"); return c.M; // (ignored)
	}
}

P_ExprConstant operator+(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	switch (common_type(c1,c2)) {
	case _int_        : return c1.n+c2.n;
	case _double_     : return c1._2double()+c2._2double();
	case _itv_        : return c1._2itv()+c2._2itv();
	case _int_vec_    :
	case _double_vec_ :
	case _itv_vec_    : if (c1.v.size()!=c2.v.size()) {
							ibexerror("Bad dimensions in vector addition");
							return -1; // (ignored)
						}
						return c1.v+c2.v;
	default           : if ((c1.M.nb_rows()!=c2.M.nb_rows()) || (c1.M.nb_cols()!=c2.M.nb_cols())) {
							ibexerror("Bad dimensions in matrix addition");
							return -1; // (ignored)
						}
						return c1.M+c2.M;
	}
}

P_ExprConstant operator-(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	switch (common_type(c1,c2)) {
	case _int_        : return c1.n-c2.n;
	case _double_     : return c1._2double()-c2._2double();
	case _itv_        : return c1._2itv()-c2._2itv();
	case _int_vec_    :
	case _double_vec_ :
	case _itv_vec_    : if (c1.v.size()!=c2.v.size()) {
							ibexerror("Bad dimensions in vector subtraction");
							return -1; // (ignored)
						}
						return c1.v-c2.v;
	default           : if ((c1.M.nb_rows()!=c2.M.nb_rows()) || (c1.M.nb_cols()!=c2.M.nb_cols())) {
							ibexerror("Bad dimensions in matrix subtraction");
							return -1; // (ignored)
						}
						return c1.M-c2.M;
	}
}

P_ExprConstant operator-(const P_ExprConstant& c) {
	switch (c.type) {
	case _int_        : return -c.n;
	case _double_     : return -c.r;
	case _itv_        : return -c.x;
	case _int_vec_    :
	case _double_vec_ :
	case _itv_vec_    : return -c.v;
	default           : return -c.M;
	}
}

P_ExprConstant sign(const P_ExprConstant& c) {
	switch (c.type) {
	case _int_     : if (c.n>=0) return 1; else if (c.n<0) return -1;
	case _double_  : if (c.r>=0) return 1; else if (c.r<0) return -1;
	case _itv_     : return sign(c.x);
	default        : ibexerror("Cannot use \"sign\" with vectors or matrices");
				     return -1; // (ignored)
	}
}

P_ExprConstant operator*(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	/* scalar-matrix multiplication */
	if (c1.is_scalar() && !c2.is_scalar()) {
		if (c2.type==_itv_vec_) return c1._2itv()*c2.v;
		else return c1._2itv()*c2.M;
	}
	/* matrix-vector multiplication */
	if (c1.type==_itv_mat_ && (c2.type==_int_vec_ || c2.type==_double_vec_ || c2.type==_itv_vec_)) {
		if (c2.v.size()!=c1.M.nb_cols()) {
			ibexerror("Bad dimensions in matrix-vector multiplication");
			return -1; // (ignored)
		} else return c1.M*c2.v;
	}

	/* Multiplication with sibling types */
	switch (common_type(c1,c2)) {
	case _int_     : return c1.n*c2.n;
	case _double_  : return c1._2double()*c2._2double();
	case _itv_     : return c1._2itv()*c2._2itv();
	case _itv_vec_ : return c1._2itvv()*c2._2itvv(); // inner or outer product
	default        : if (c1.M.nb_cols()!=c2.M.nb_rows()) {
						ibexerror("Bad dimensions in matrix multiplication");
						return -1; // (ignored)
					}
					return c1.M*c2.M;
	}
}

P_ExprConstant operator/(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	double div;
	switch (common_type(c1,c2)) {
	case _int_  :
		if (c2.n==0) { ibexerror("Division by zero"); return -1; }
		div= ((double) c1.n)/((double) c2.n);
		if (floor(div)==div) return (int) div;
		else return div;
	case _double_ : {
		if (c2._2double()==0) { ibexerror("Division by zero"); return -1; }
		return c1._2double()/c2._2double();
	}
	case _itv_  : return c1._2itv()/c2._2itv();
	default     : ibexerror("Cannot divide vectors nor matrices"); return -1;
	}
}

P_ExprConstant max(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	switch (common_type(c1,c2)) {
	case _int_    : return c1.n>c2.n? c1.n : c2.n;
	case _double_ : return c1._2double()>c2._2double()? c1._2double() : c2._2double();
	case _itv_    : return max(c1._2itv(),c2._2itv());
	default       : ibexerror("Cannot use \"max\" with vectors or matrices"); return -1;
	}
}

P_ExprConstant min(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	switch (common_type(c1,c2)) {
	case _int_    : return c1.n<c2.n? c1.n : c2.n;
	case _double_ : return c1._2double()<c2._2double()? c1._2double() : c2._2double();
	case _itv_    : return min(c1._2itv(),c2._2itv());
	default       : ibexerror("Cannot use \"min\" with vectors or matrices"); return -1;
	}
}


P_ExprConstant pow(const P_ExprConstant& c, const P_ExprConstant& p) {
	switch (common_type(c,p)) {
	case _int_    :
	case _double_ : return ::pow(c._2double(), p._2double());
	case _itv_    : return pow(c._2itv(),p._2itv());
	default       : ibexerror("double or Interval expected"); return -1;
	}
}

typedef double (*double_func)(double);       // unary float function (in math.h)
typedef double (*double_func2)(double,double); // binary float function (in math.h)

typedef Interval (*itv_func)(const Interval&);                   // unary Interval function (in Function.h of Profil/Bias)
typedef Interval (*itv_func2)(const Interval&, const Interval&); // binary Interval function (in Function.h of Profil/Bias)

P_ExprConstant apply(double_func doublef, itv_func itvf, const P_ExprConstant& c) {
	switch (c.type) {
	case _int_    : return doublef(c.n);
	case _double_ : return doublef(c.r);
	case _itv_    : return itvf(c.x);
	default       : ibexerror("double or Interval expected"); return -1;
	}
}

P_ExprConstant apply2(double_func2 doublef, itv_func2 itvf, const P_ExprConstant& c1, const P_ExprConstant& c2) {
	switch (common_type(c1,c2)) {
	case _int_    : return doublef(c1.n, c2.n);
	case _double_ : return doublef(c1._2double(), c2._2double());
	case _itv_    : return itvf(c1._2itv(), c2._2itv());
	default       : ibexerror("double or Interval expected"); return -1;
	}
}

P_ExprConstant inf(const P_ExprConstant& c) {
	switch (c.type) {
	case _int_        :
	case _double_     :
	case _int_vec_    :
	case _double_vec_ : ibexerror("Inf can only be used with Intervals");
	case _itv_        : return c.x.lb();
	case _itv_vec_    : ibexerror("Inf with vectors not implemented yet");
	default           : ibexerror("Inf with matrices not implemented yet");
						return -1;
	}
}

P_ExprConstant mid(const P_ExprConstant& c) {
	switch (c.type) {
	case _int_        :
	case _double_     :
	case _int_vec_    :
	case _double_vec_ : ibexerror("Mid can only be used with Intervals");
	case _itv_        : return c.x.mid();
	case _itv_vec_    : ibexerror("Mid with vectors not implemented yet");
	default           : ibexerror("Mid with matrices not implemented yet");
						return -1;
	}
}

P_ExprConstant sup(const P_ExprConstant& c) {
	switch (c.type) {
	case _int_        :
	case _double_     :
	case _int_vec_    :
	case _double_vec_ : ibexerror("Sup can only be used with Intervals");
	case _itv_        : return c.x.ub();
	case _itv_vec_    : ibexerror("Sup with vectors not implemented yet");
	default           : ibexerror("Sup with matrices not implemented yet");
						return -1;
	}
}

P_ExprConstant abs(const P_ExprConstant& c) {
	return apply(::fabs,ibex::abs,c);
}

P_ExprConstant sqrt(const P_ExprConstant& c) {
	return apply(::sqrt,ibex::sqrt,c);
}

P_ExprConstant exp(const P_ExprConstant& c) {
	return apply(::exp,ibex::exp,c);
}

P_ExprConstant log(const P_ExprConstant& c) {
	return apply(::log,ibex::log,c);
}

P_ExprConstant cos(const P_ExprConstant& c) {
	return apply(::cos,ibex::cos,c);
}

P_ExprConstant sin(const P_ExprConstant& c) {
	return apply(::sin,ibex::sin,c);
}

P_ExprConstant tan(const P_ExprConstant& c) {
	return apply(::tan,ibex::tan,c);
}

P_ExprConstant acos(const P_ExprConstant& c) {
	return apply(::acos,ibex::acos,c);
}

P_ExprConstant asin(const P_ExprConstant& c) {
	return apply(::asin,ibex::asin,c);
}

P_ExprConstant atan(const P_ExprConstant& c) {
	return apply(::atan,ibex::atan,c);
}

P_ExprConstant atan2(const P_ExprConstant& c1, const P_ExprConstant& c2) {
	return apply2(::atan2,ibex::atan2,c1,c2);
}

P_ExprConstant cosh(const P_ExprConstant& c) {
	return apply(::cosh,ibex::cosh,c);
}

P_ExprConstant sinh(const P_ExprConstant& c) {
	return apply(::sinh,ibex::sinh,c);
}

P_ExprConstant tanh(const P_ExprConstant& c) {
	return apply(::tanh,ibex::tanh,c);
}

P_ExprConstant acosh(const P_ExprConstant& c) {
	return apply(::acosh,ibex::acosh,c);
}

P_ExprConstant asinh(const P_ExprConstant& c) {
	return apply(::asinh,ibex::asinh,c);
}


} // end namespace parser
} // end namespace ibex

public class Ibex {

	/* Possible contraction strategies. */
	public static final int COMPO      = 0;
	public static final int HC4        = 1;
	public static final int HC4_NEWTON = 2;
	
	/* Constants for the status of a contraction. */
	public static final int FAIL     = 0;
	public static final int ENTAILED = 1;
	public static final int CONTRACT = 2;
	public static final int NOTHING  = 3;
	
	/* Constants for describing a boolean domain (by an integer). */
	public static final int FALSE         = 0;
	public static final int TRUE          = 1;
	public static final int FALSE_OR_TRUE = 2;
	
    static {
    	System.loadLibrary("ibex-java");
    }

    /**
     * Create a new IBEX constraint with a default contractor.
     * 
     * The default contractor is COMPO.
     * 
     * Example: add_ctr(2,{0}={1}) will add the constraint x=y.
     * 
     * @param nb_var - Number of variables.
     * @param syntax - The constraint
     */
    public native void add_ctr(int nb_var, String syntax);
    
    /**
     * Same as add_ctr except that a specific contractor is used.
     * 
     * @param nb_var - Number of variables
     * @param syntax - The constraint
     * @param option - A value between COMPO, HC4 or HC4_NEWTON.
     */
    public native void add_ctr(int nb_var, String syntax, int option);
    
    /**
     * Constraint nb_var variables to be integer variables.
     * 
     * @param nb_var - Number of variables
     * /////@param mask   - Set whether a variable is integral or not. 
     * /////                mask[i]==true <=> the ith variable is integral.
     */
    public native void add_int_ctr(int nb_var);
    
    
    /**
     * Call the contractor associated to a constraint or its negation.
     *
     * We consider here the reified constraint R(b,c) : b<=>c(x_1,...,x_n).
     * 
     * @param i      - Number of the constraint (in the order of creation)
     * @param bounds - The bounds of domains under the following form:
     *                 (x1-,x1+,x2-,x2+,...,xn-,xn+), where xi- (resp. xi+) is the
     *                 lower (resp. upper) bound of the domain of x_i.
     * @param reif   - Domain of the reification variable b with the following accepted values:
     *                 FALSE, TRUE, FALSE_OR_TRUE.
     *              
     * @return The status of contraction or fail/entailment test. Note that the name of the constant
     * in return refers to the constraint c, not R. Hence "FAIL" means that no tuple satisfies c (should  
     * R be satisfiable or not).
     * 
     *    FAIL     - No tuple satisfies c. If reif==FALSE, the bounds of x may have been impacted (the part 
     *               of the domain inside c has been removed and the remaining part has been proven to be 
     *               outside c). If reif==TRUE, the bounds have not been impacted but we have to consider 
     *               that the domain has been reduced to the empty set. If reif==FALSE_OR_TRUE, bounds have 
     *               not been impacted.
     *        
     *    ENTAILED - All the tuples satisfy the constraint. If reif==FALSE, the bounds have not been impacted 
     *               but we have to consider that the domain has been reduced to the empty set. If reif==TRUE, 
     *               the bounds of x may have been impacted (the part of the domain outside c has been removed 
     *               and the remaining part has been proven to be inside c). If reif==FALSE_OR_TRUE, bounds have 
     *               not been impacted.
     *        
     *    CONTRACT - This value can only be returned if reif==FALSE or reif==TRUE. At least one bound of x has 
     *               been reduced by more than 0.1%. If reif==FALSE, the removed part of the domain is inside c.
     *               If reif==TRUE, the removed part is outside.
     *        
     *    NOTHING  - No bound has been reduced and nothing could be proven.
     */
    public native int contract(int i, double bounds[], int reif);    
 
    
    /**
     * Same as contract(int, double bounds[], int reif) with reif=TRUE.
     */
    public native int contract(int i, double bounds[]);   
    

    /**
     * Free IBEX structures from memory
     */
    public native void release();
};

/* ============================================================================
 * I B E X - Implementation of the Affine2 class based on fAF version 2
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Jordan Ninin
 * Created     : Jul 16, 2013
 * ---------------------------------------------------------------------------- */

namespace ibex {


double Affine2::twoSum(double a, double b, double *res) {
	*res = a+b;
	double a2 = *res - b;
	double b2 = *res - a2;
	double delta_a = a - a2;
	double delta_b = b - b2;
	return delta_a + delta_b;
}

/////////////////////
// CODE extract from "Handbook of Floating-Point Arithmetic"
double Affine2::twoProd(double x, double y, double *r_1)
{
	int SHIFT_POW = 27; //  53 / 2 for double precision.
	double x_high, x_low;
	double y_high, y_low;
	double t_1;
	double t_2;
	double t_3;
	Split(x, SHIFT_POW, &x_high, &x_low);
	Split(y, SHIFT_POW, &y_high, &y_low);
	*r_1 = x * y;
	t_1 = -*r_1 + x_high * y_high ;
	t_2 =   t_1 + x_high * y_low;
	t_3 =	t_2 + x_low * y_high;
	return  t_3 + x_low * y_low;
}

void Affine2::Split(double x, int sp, double *x_high, double *x_low)
{
	unsigned long C = (1UL << sp) + 1;
	double gamma = C * x;
	double delta = x - gamma;
	*x_high= gamma + delta;
	*x_low= x - *x_high;
}
//////////////////////////


Affine2::Affine2() :
		 _n		(-2		),
		 _val	(NULL	),
		 _err	(POS_INFINITY)	{
 }

Affine2::Affine2(int n, int m, const Interval& itv) :
			_n 		(n),
			_val	(NULL),
			_err	(0.0)
{
	assert((n>=0) && (m>=0) && (m<=n));
	if (!(itv.is_unbounded()||itv.is_empty())) {
		_val	=new double[n + 1];
		_val[0] = itv.mid();
		for (int i = 1; i <= n; i++){
			_val[i] = 0.0;
		}

		if (m == 0) {
			_err = itv.rad();
		} else {
			_val[m] = itv.rad();
		}
	} else {
		*this = itv;
	}
}


Affine2::Affine2(const double d) :
			_n 		(0),
			_val	(NULL),
			_err	(0.0) {
	if (fabs(d)<POS_INFINITY) {
		_val = new double[1];
		_err = 0.0; //abs(d)*AF_EE();
		_val[0] = d;
	} else {
		if (d>0) {
			_n = -3;
		} else {
			_n = -4;
		}
		_err = d;
	}
}


Affine2::Affine2(const Interval & itv):
			_n 		(0),
			_val	(NULL),
			_err	(0.0) {

	if (itv.is_empty()) {
		_n = -1;
	} else if (itv.ub()>= POS_INFINITY && itv.lb()<= NEG_INFINITY ) {
		_n = -2;
	} else if (itv.ub()>= POS_INFINITY ) {
		_n = -3;
		_err = itv.lb();
	} else if (itv.lb()<= NEG_INFINITY ) {
		_n = -4;
		_err = itv.ub();
	} else  {
		_n = 0;
		_val	= new double[1];
		_val[0] = itv.mid();
		_err	= itv.rad();
	}
}


Affine2::Affine2(const Affine2& x) :
		_n		(x._n),
		_val	(NULL	 ),
		_err	(x._err ) {
	if (is_actif()) {
		_val =new double[x.size() + 1];
		for (int i = 0; i <= x.size(); i++){
			_val[i] = x.val(i);
		}
	}
}


const Interval Affine2::itv() const {

	if (is_actif()) {
		Interval res(_val[0]);
		Interval pmOne(-1.0, 1.0);
		for (int i = 1; i <= _n; i++){
			res += (_val[i] * pmOne);
		}
		res += _err * pmOne;
		return res;
	} else if (_n==-1) {
		return Interval::EMPTY_SET;
	} else if (_n==-2) {
		return Interval::ALL_REALS;
	} else if (_n==-3) {
		return Interval(_err,POS_INFINITY);
	} else  {  //if (_n==-4)
		return Interval(NEG_INFINITY,_err);
	}

}

Affine2& Affine2::operator=(const Affine2& x) {
	if (this != &x) {
		_err = x.err();
		if (x.is_actif()) {
			if (_n!=x.size()) {
				_n =x.size();
				if (_val!=NULL) { delete[] _val; }
				_val = new double[_n+1];
			}
			if (_val==NULL) _val = new double[_n+1];

			for (int i = 0; i <= x.size(); i++) {
				_val[i] = x.val(i);
			}
		} else {
			_n = x._n;
			if (_val != NULL) {
				delete[] _val;
				_val = NULL;
			}
		}
	}
	return *this;

}

Affine2& Affine2::operator=(double d) {

	if (fabs(d)<POS_INFINITY) {
		if (_val!=NULL) { delete[] _val; }
		_n = 0;
		_val = new double[1];
		_err = 0.0; //abs(d)*AF_EE();
		_val[0] = d;
	} else {
		if (d>0) {
			_n = -3;
		} else {
			_n = -4;
		}
		_err = d;
		if (_val != NULL) {
			delete[] _val;
			_val = NULL;
		}
	}
	return *this;
}

Affine2& Affine2::operator=(const Interval& x) {

	if (x.is_empty()) {
		_n = -1;
		_err = 0.0;
		if (_val != NULL) {
			delete[] _val;
			_val = NULL;
		}
	} else if (x.ub()>= POS_INFINITY && x.lb()<= NEG_INFINITY ) {
		_n = -2;
		_err = 0.0;
		if (_val != NULL) {
			delete[] _val;
			_val = NULL;
		}
	} else if (x.ub()>= POS_INFINITY ) {
		_n = -3;
		_err = x.lb();
		if (_val != NULL) {
			delete[] _val;
			_val = NULL;
		}
	} else if (x.lb()<= NEG_INFINITY ) {
		_n = -4;
		_err = x.ub();
		if (_val != NULL) {
			delete[] _val;
			_val = NULL;
		}
	} else  {
		if (_val!=NULL) { delete[] _val; }
		_n = 0;
		_val	= new double[1];
		_val[0] = x.mid();
		_err	= x.rad();
	}
	return *this;
}



/** \brief Return (-x) */
Affine2 Affine2::operator-() const {
	Affine2 res;
	res._n = _n;
	res._err = _err;
	if (is_actif()) {
		res._val = new double[_n+1];
		for (int i = 0; i <= _n; i++) {
			res._val[i] = (-_val[i]);
		}

	}
	return res;
}




Affine2& Affine2::saxpy(double alpha, const Affine2& y, double beta, double ddelta, bool B1, bool B2, bool B3, bool B4) {
//std::cout << "saxpy IN " << alpha << " x " << *this << " + " << y << " + "<< beta << " +error " << ddelta << " / "<< B1 << B2 << B3 << B4 << std::endl;
	double temp, ttt, sss, eee;
	int i;
//	std::cout << "in saxpy alpha=" << alpha  <<  "  beta= " <<  beta <<   "  delta = " << ddelta   << std::endl;
	if (is_actif()) {
		if (B1) {  // multiply by a scalar alpha
			if (alpha==0.0) {
				for (i=0; i<=_n;i++) {
					_val[i]=0;
				}
				_err = 0;
			}
			else if ((fabs(alpha)) < POS_INFINITY) {
				ttt= 0.0;
				sss= 0.0;
				for (i=0; i<=_n;i++) {
					eee = twoProd(_val[i], alpha, &temp);
					_val[i] = temp;
					ttt = (1+2*AF_EM())*(ttt+fabs(eee));
					if (fabs(_val[i])<AF_EC()) {
						sss = (1+2*AF_EM())*(sss+ fabs(_val[i]));
						_val[i] = 0.0;
					}
				}

//				_err = (1+2*AF_EM())*((1+2*AF_EM())*fabs(alpha)*_err+AF_EE()*AF_EM()*ttt + AF_EE()*sss);
				_err = (1+2*AF_EM())*(
						((1+2*AF_EM())*fabs(alpha)*_err) +
						((AF_EE()*ttt) +
						(AF_EE()*sss))
						);

			}
			else {
				*this = itv()*alpha;
			}
		}

		if (B2) {  // add a affine2 form y

			if (y.is_actif()) {
				if (_n==y.size()) {

					ttt=0.0;
					sss=0.0;
					for(i=0;i<=_n;i++) {
						eee = twoSum(_val[i], y.val(i), &temp);
						ttt = (1+2*AF_EM())*(ttt+fabs(eee));
						if (fabs(temp)<AF_EC()) {
							sss = (1+2*AF_EM())*(sss+ fabs(temp));
							_val[i] = 0.0;
						}
						else {
							_val[i]=temp;
						}
					}
//					_err = (1+2*AF_EM())*((_err+y.err())+ (AF_EE()*(AF_EM()*ttt)+AF_EE()*sss));
					_err = (1+2*AF_EM())*(
							(_err+y.err()) +
							((AF_EE()*(ttt)) +
							(AF_EE()*sss))
							);

				} else  {
					if (_n>y.size()) {
						*this += y.itv();
					} else {
						Interval tmp1 = itv();
						*this = y;
						*this += tmp1;
					}
				}
			}
			else { // y is not a valid affine2 form. So we add y.itv() such as an interval
				*this = itv()+y.itv();
			}
		}
		if (B3) {  //add a constant beta
			if ((fabs(beta))<POS_INFINITY) {
				ttt=0.0;
				sss=0.0;
				eee = twoSum(_val[0],beta,&temp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				if (fabs(temp)<AF_EC()) {
					sss = (1+2*AF_EM())*(sss+fabs(temp));
					_val[0] = 0.0;
				}
				else {
					_val[0]=temp;
				}
//				_err = (1+2*AF_EM())*(_err+ (AF_EE()*(AF_EM()*ttt)+AF_EE()*sss));
				_err = (1+2*AF_EM())*(
						_err +
						(AF_EE()*(ttt)+
						AF_EE()*sss)
						);

			}
			else {
				*this = itv()+beta;
			}
		}

		if (B4) {  // add an error  ddelta

			if ((fabs(ddelta))<POS_INFINITY) {
				ttt=0.0;
				sss=0.0;
				eee = twoSum(_err,ddelta, &temp);
				ttt = (1+2*AF_EM())*(fabs(eee));
				if (fabs(temp)<AF_EC()) {
					sss = (1+2*AF_EM())*(fabs(temp));
					temp =0;
				}
//				_err = (1+2*AF_EM())*(temp+ (AF_EE()*(AF_EM()*ttt)));;
				_err = (1+2*AF_EM())*(
						temp +
						(AF_EE()*(ttt) +
						AF_EE()*sss)
						);;

			}
			else {
				*this = itv()+Interval(-ddelta,ddelta);
			}
		}

		if (_val != NULL) {
			bool b = (_err<POS_INFINITY);
			for (i=0;i<=_n;i++) {
				b &= (fabs(_val[i])<POS_INFINITY);
			}
			if (!b) {
				*this = Interval::ALL_REALS;
			}
		}

	} else {
		if (B1) {  //scalar alpha
			*this = itv()* alpha;
		}
		if (B2) {  // add y
			*this = itv()+ y.itv();
		}
		if (B3) {  //constant beta
			*this = itv()+ beta;
		}
		if (B4) {  // error  delta
			*this = itv()+ Interval(-ddelta,ddelta);
		}
	}
//	std::cout << " saxpy OUT x= "<< *this<<std::endl;
	return *this;

}

//TODO
Affine2& Affine2::operator*=(const Affine2& y) {
//	std::cout << "in *= "<< *this <<std::endl;

	if (is_actif() && (y.is_actif())) {

		if (_n==y.size()) {
			double Sx, Sy, Sxy, Sz, ttt, sss, ppp, tmp, xVal0, eee;
			int i;
			double * xTmp;

			xTmp = new double[_n + 1];
			Sx=0.0; Sy=0.0; Sxy=0.0; Sz=0.0; ttt=0.0; sss=0.0; ppp=0.0; tmp=0.0; xVal0=0.0; eee=0.0;

			for (i = 1; i <= _n; i++) {
				eee = twoProd(_val[i],y.val(i), &ppp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));

				eee = twoSum(Sz,ppp, &tmp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				Sz = tmp;

				if (fabs(Sz) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(Sz));
					Sz = 0.0;
				}

				eee = twoSum(Sxy,fabs(ppp), &tmp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				Sxy = tmp;

				if (fabs(Sxy) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(Sxy));
					Sxy = 0.0;
				}

				eee = twoSum(Sx,fabs(_val[i]), &tmp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				Sx = tmp;

				if (fabs(Sx) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(Sx));
					Sx = 0.0;
				}
				eee = twoSum(Sy,fabs(y.val(i)), &tmp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				Sy = tmp;

				if (fabs(Sy) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(Sy));
					Sy = 0.0;
				}

			}

			xVal0 = _val[0];
			// RES = X%T(0) * res
			for (i = 0; i <= _n; i++) {
				eee = twoProd(_val[i],y.val(0), &ppp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				_val[i] = ppp;

				if (fabs(_val[i]) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(_val[i]));
					_val[i] = 0.0;
				}
			}

			// Xtmp = X%T(0) * Y
			xTmp[0] = 0.0;
			for (i = 1; i <= _n; i++) {
				eee = twoProd(xVal0,y.val(i), &ppp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				xTmp[i] = ppp;

				if (fabs(xTmp[i]) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(xTmp[i]));
					xTmp[i] = 0.0;
				}

			}

			//RES =  RES + Xtmp = ( Y%(0) * X ) + ( X%T(0) * Y - X%T(0)*Y%(0) )
			for (i = 0; i <= _n; i++) {

				eee = twoSum(_val[i],xTmp[i], &tmp);
				ttt = (1+2*AF_EM())*(ttt+fabs(eee));
				_val[i] = tmp;

				if (fabs(_val[i]) < AF_EC()) {
					sss = (1+2*AF_EM())*(sss+ fabs(_val[i]));
					_val[i] = 0.0;
				}

			}

			eee = twoProd(0.5,Sz, &ppp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));

			eee = twoSum(_val[0],ppp, &tmp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));
			_val[0] = tmp;

			if (fabs(_val[0]) < AF_EC()) {
				sss = (1+2*AF_EM())*(sss+ fabs(_val[0]));
				_val[0] = 0.0;
			}

			eee = twoSum(_err,Sx, &tmp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));

			eee = twoSum(y.err(),Sy, &ppp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));


			_err = (1+ 2*AF_EM()) * (
					((1+ 2*AF_EM()) *fabs(y.val(0)) * _err)  +
					((1+ 2*AF_EM()) *fabs(xVal0) * y.err())  +
					((1+ 2*AF_EM()) *(tmp * ppp)) +
					((1- 2*AF_EM()) *(-0.5) *  Sxy)  +
//					(AF_EE() * (AF_EM() * ttt))  +
					(AF_EE() * (ttt))  +
					(AF_EE() * sss)
					);

			{
				bool b = (_err<POS_INFINITY);
				for (i=0;i<=_n;i++) {
					b &= (fabs(_val[i])<POS_INFINITY);
				}
				if (!b) {
					*this = Interval::ALL_REALS;
				}
			}
			delete[] xTmp;

		} else {
			if (_n>y.size()) {
				*this *= y.itv();
			} else {
				Interval tmp1 = this->itv();
				*this = y;
				*this *= tmp1;
			}
		}


	} else {
		*this = itv()*y.itv();
	}
//	std::cout << "out *= "<< *this<<std::endl;

	return *this;
}

Affine2& Affine2::operator*=(const Interval& y) {
	if (	(!is_actif())||
			y.is_empty()||
			y.is_unbounded() ) {
		*this = itv()*y;

	} else {
		double  ttt, sss,  yVal0, eee, temp;
		int i;
//std::cout << "in *  "<<y<<std::endl;
//saxpy(y.mid(), Affine2(), 0.0, y.rad(), true, false, false, true);

		ttt=0.0; sss=0.0;  yVal0=0.0; eee=0.0;
		yVal0 = y.mid();
		// RES = X%(0) * res
		for (i=0; i<=_n;i++) {
			eee = twoProd(_val[i], yVal0, &temp);
			_val[i] = temp;
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));
			if (fabs(_val[i])<AF_EC()) {
				sss = (1+2*AF_EM())*(sss+ fabs(_val[i]));
				_val[i] = 0.0;
			}
		}

		//_err *= (fabs(yVal0)+Interval(y.rad()));
		_err = (1+2*AF_EM())*(
				(1+2*AF_EM())*(abs(y).ub())*_err +
//				AF_EE()*AF_EM()*ttt +
				((AF_EE()*ttt) +
				(AF_EE()*sss))
				);

		{
			bool b = (_err<POS_INFINITY);
			for (i=0;i<=_n;i++) {
				b &= (fabs(_val[i])<POS_INFINITY);
			}
			if (!b) {
				*this = Interval::ALL_REALS;
			}
		}

	}
	return *this;
}


Affine2& Affine2::sqr(const Interval itv) {
//	std::cout << "in sqr "<<std::endl;

	bool b = (!(itv.is_empty()||itv.is_unbounded()));
	if (	(!is_actif())||
			itv.is_empty()||
			itv.is_unbounded()||
			(itv.diam() < AF_EC())  ) {
		*this = pow(itv,2);

	} else  {

		double Sx, Sx2, ttt, sss, ppp, x0, eee,tmp;
		Sx = 0; Sx2 = 0; ttt = 0; sss = 0; ppp = 0; x0 = 0; eee =0.0; tmp =0.0;

		// compute the error
		for (int i = 1; i <= _n; i++) {

			eee = twoProd(_val[i],_val[i], &ppp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));

			eee = twoSum(Sx2,ppp, &tmp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));
			Sx2 = tmp;

			if (fabs(Sx2) < AF_EC()) {
				sss = (1+2*AF_EM())*(sss+ fabs(Sx2));
				Sx2 = 0.0;
			}

			eee = twoSum(Sx,fabs(_val[i]), &tmp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));
			Sx = tmp;

			if (fabs(Sx) < AF_EC()) {
				sss = (1+2*AF_EM())*(sss+ fabs(Sx));
				Sx = 0.0;
			}

		}
		// compute 2*_val[0]*(*this)
		x0 = _val[0];

		eee = twoProd(x0,x0, &ppp);
		ttt = (1+2*AF_EM())*(ttt+fabs(eee));
		_val[0] = ppp;

		if (fabs(_val[0]) < AF_EC()) {
			sss = (1+2*AF_EM())*(sss+ fabs(_val[0]));
			_val[0] = 0.0;
		}

		// compute 2*_val[0]*(*this)
		for (int i = 1; i <= _n; i++) {

			eee = twoProd((2*x0),_val[i], &ppp);
			ttt = (1+2*AF_EM())*(ttt+fabs(eee));
			_val[i] = ppp;

			if (fabs(_val[i]) < AF_EC()) {
				sss = (1+2*AF_EM())*(sss+ fabs(_val[i]));
				_val[i] = 0.0;
			}

		}

		eee = twoProd(0.5,Sx2, &ppp);
		ttt = (1+2*AF_EM())*(ttt+fabs(eee));

		eee = twoSum(_val[0],ppp, &tmp);
		ttt = (1+2*AF_EM())*(ttt+fabs(eee));
		_val[0] = tmp;

		if (fabs(_val[0]) < AF_EC()) {
			sss = (1+2*AF_EM())*(sss+ fabs(_val[0]));
			_val[0] = 0.0;
		}

		eee = twoSum(_err,Sx, &tmp);
		ttt = (1+2*AF_EM())*(ttt+fabs(eee));

		_err = (1+ 2*AF_EM()) * (
				((1+ 2*AF_EM()) *2*fabs(x0) * _err)  +
				((1+ 2*AF_EM()) *(tmp * tmp)) +
				((1- 2*AF_EM()) *(-0.5) *  Sx2)  +
//					(AF_EE() * (AF_EM() * ttt))  +
				(AF_EE() * (ttt))  +
				(AF_EE() * sss)
				);

		{
			bool b = (_err<POS_INFINITY);
			for (int i=0;i<=_n;i++) {
				b &= (fabs(_val[i])<POS_INFINITY);
			}
			if (!b) {
				*this = Interval::ALL_REALS;
			}
		}

	}

//	std::cout << "out sqr "<<std::endl;
	return *this;
}




}// end namespace ibex





/* ============================================================================
 * I B E X - Interval Vector definition
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Dec 05, 2011
 * ---------------------------------------------------------------------------- */

#include "ibex_IntervalVector.h" // just for the IDE

namespace ibex {

inline IntervalVector::IntervalVector(int n) : n(n), vec(new Interval[n]) {
	assert(n>=1);
	for (int i=0; i<n; i++) vec[i]=Interval::ALL_REALS;
}

inline IntervalVector::IntervalVector(int n, const Interval& x) : n(n), vec(new Interval[n]) {
	assert(n>=1);
	for (int i=0; i<n; i++) vec[i]=x;
}

inline IntervalVector::IntervalVector(const IntervalVector& x) : n(x.n), vec(new Interval[x.n]) {
	for (int i=0; i<n; i++) vec[i]=x[i];
}

inline IntervalVector::IntervalVector(int n, double bounds[][2]) : n(n), vec(new Interval[n]) {
	for (int i=0; i<n; i++)
		vec[i]=Interval(bounds[i][0],bounds[i][1]);
}

inline IntervalVector::IntervalVector(const Vector& x) : n(x.size()), vec(new Interval[n]) {
	for (int i=0; i<n; i++) vec[i]=x[i];
}

inline IntervalVector IntervalVector::empty(int n) {
	return IntervalVector(n, Interval::EMPTY_SET);
}

inline IntervalVector::~IntervalVector() {
	delete[] vec;
}

inline const Interval& IntervalVector::operator[](int i) const {
	assert(i>=0 && i<n);
	return vec[i];
}

inline Interval& IntervalVector::operator[](int i) {
	assert(i>=0 && i<n);
	return vec[i];
}

inline void IntervalVector::set_empty() {
	// warning: do not insert this test:
	//	 if (isEmpty()) return;
	// because we call set_empty() from set(...) and the first component
	// may be empty in an intermediate state

	//for (int i=0; i<size(); i++)
	//	(*this)[i]=Interval::EMPTY_SET;
	(*this)[0]=Interval::EMPTY_SET;
}

inline void IntervalVector::resize(int n2) {
	assert(n2>=1);
	if (n2==size()) return;

	Interval* newVec=new Interval[n2];
	int i=0;
	for (; i<size() && i<n2; i++)
		newVec[i]=vec[i];
	for (; i<n2; i++)
		newVec[i]=Interval::ALL_REALS;
	if (vec!=NULL) // vec==NULL happens when default constructor is used (n==0)
		delete[] vec;

	n   = n2;
	vec = newVec;
}

inline IntervalVector IntervalVector::subvector(int start_index, int end_index) {
	assert(!is_empty());
	assert(end_index>=0 && start_index>=0);

	if (end_index>=size() || start_index>end_index)
		throw NonRecoverableException("Invalid indices for IntervalVector::subvector");

	IntervalVector v(end_index-start_index+1);
	int j=0;
	for (int i=start_index; i<=end_index; i++) {
		v[j++]=(*this)[i];
	}
	return v;
}

inline IntervalVector& IntervalVector::operator=(const IntervalVector& x) {
	assert(size()==x.size()); // throw InvalidIntervalVectorOp("Cannot set a IntervalVector to a IntervalVector with different dimension");

	if (x.is_empty())
		set_empty();
	else
		// don't use "set(...)" because the test "is_empty()" called inside
		// may return prematurely in case "this" is empty.
		// use physical copy instead:
		for (int i=0; i<size(); i++)
			(*this)[i]=x[i];

	return *this;
}

inline IntervalVector& IntervalVector::operator&=(const IntervalVector& x)  {
	// dimensions are non zero henceforth
	if (size()!=x.size()) throw InvalidIntervalVectorOp("Cannot intersect IntervalVectores with different dimensions");

	if (is_empty()) return *this;
	if (x.is_empty()) { set_empty(); return *this; }

	for (int i=0; i<size(); i++) {
		(*this)[i] &= x[i];
		if ((*this)[i].is_empty()) {
			set_empty();
			return *this;
		}
	}
	return *this;
}

inline IntervalVector& IntervalVector::operator|=(const IntervalVector& x)  {
	// dimensions are non zero henceforth
	if (size()!=x.size()) throw InvalidIntervalVectorOp("Cannot make the hull of IntervalVectores with different dimensions");

	if (x.is_empty()) return *this;
	if (is_empty()) { *this=x; return *this; }

	for (int i=0; i<size(); i++) {
		(*this)[i] |= x[i];
	}
	return *this;
}

inline IntervalVector IntervalVector::operator&(const IntervalVector& x) const {
	return IntervalVector(*this) &= x;
}

inline IntervalVector IntervalVector::operator|(const IntervalVector& x) const {
	return IntervalVector(*this) |= x;
}

inline bool IntervalVector::operator==(const IntervalVector& x) const {
	if (n!=x.size()) return false;
	if (is_empty() || x.is_empty()) return is_empty() && x.is_empty();
	for (int i=0; i<n; i++)
		if ((*this)[i]!=(x[i])) return false;
	return true;
}

inline bool IntervalVector::operator!=(const IntervalVector& x) const {
	return !(*this==x);
}

inline int IntervalVector::size() const {
	return n;
}

inline Vector IntervalVector::mid() const {
	assert(!is_empty());

	Vector mV(size());
	for (int i=0; i<size(); i++) {
		double m =  (*this)[i].mid();
		mV[i]=m;
	}
	return mV;
}

inline bool IntervalVector::is_empty() const {
	return (*this)[0].is_empty();
}

inline bool IntervalVector::is_flat() const {
	if (is_empty()) return true;
	for (int i=0; i<size(); i++)
		if ((*this)[i].is_degenerated()) // don't use diam() because of roundoff
			return true;
	return false;
}


inline bool IntervalVector::contains(const Vector& x) const {
  for (int i=1; i<=size(); i++)
    if (!(*this)[i].contains(x[i])) return false;
  return true;
}

inline bool IntervalVector::is_unbounded() const {
  if (is_empty()) return false;
  for (int i=0; i<size(); i++)
    if ((*this)[i].is_unbounded()) return true;
  return false;
}

inline bool IntervalVector::is_subset(const IntervalVector& x) const {
  if (is_empty()) return true;
  for (int i=0; i<size(); i++)
    if (!(*this)[i].is_subset(x[i])) return false;
  return true;
}

inline bool IntervalVector::is_strict_subset(const IntervalVector& x) const {
  if (is_empty() && !x.is_empty()) return true;
  if (x.is_empty()) return false;
  for (int i=0; i<size(); i++)
    if (!(*this)[i].is_strict_subset(x[i])) return false;
  return true;
}

inline bool IntervalVector::is_superset(const IntervalVector& x) const {
	return x.is_subset(*this);
}

inline bool IntervalVector::is_strict_superset(const IntervalVector& x) const {
	return x.is_strict_subset(*this);
}

inline int IntervalVector::extr_diam_index(bool min) const {
	double d=(*this)[0].diam();
	int selectedIndex=0;
	if (is_empty()) throw InvalidIntervalVectorOp("Diameter of an empty IntervalVector is undefined");
	for (int i=1; i<size(); i++) {
		double w=(*this)[i].diam();
		if (min? w<d : w>d) {
			selectedIndex=i;
			d=w;
		}
	}
	return selectedIndex;
}

inline double IntervalVector::max_diam() const {
	return (*this)[extr_diam_index(false)].diam();
}

inline double IntervalVector::min_diam() const {
	return (*this)[extr_diam_index(true)].diam();
}

/*=============================================================================== */
/*                               arithmetic                                       */
/*=============================================================================== */

inline Vector operator-(const Vector& x) {
	const int n=x.size();

	Vector y(n);
	for (int i=0; i<n; i++) {
		y[i]=-x[i];
	}
	return y;
}

inline IntervalVector operator-(const IntervalVector& x) {
	const int n=x.size();
	if (x.is_empty()) return IntervalVector::empty(n);

	IntervalVector y(n);
	for (int i=0; i<n; i++) {
		y[i]=-x[i];
	}
	return y;
}

inline Vector operator+(const Vector& x1, const Vector& x2) {
	Vector _x1(x1); 
	return _x1+=x2;
}

inline IntervalVector operator+(const Vector& x1, const IntervalVector& x2) {
	return x2+x1;
}

inline IntervalVector operator+(const IntervalVector& x1, const Vector& x2) {
	IntervalVector _x1(x1); 
	return _x1+=x2;
}

inline IntervalVector operator+(const IntervalVector& x1, const IntervalVector& x2) {
	IntervalVector _x1(x1); 
	return _x1+=x2;
}

inline Vector operator-(const Vector& x1, const Vector& x2) {
	Vector _x1(x1); 
	return _x1-=x2;
}

inline IntervalVector operator-(const Vector& x1, const IntervalVector& x2) {
	IntervalVector _mx2(-x2);
	return _mx2+=x1;
}

inline IntervalVector operator-(const IntervalVector& x1, const Vector& x2) {
	IntervalVector _x1(x1); 
	return _x1-=x2;
}

inline IntervalVector operator-(const IntervalVector& x1, const IntervalVector& x2) {
	IntervalVector _x1(x1); 
	return _x1-=x2;
}

inline double operator*(const Vector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x1.size()==x2.size());
	double y=0;
	for (int i=0; i<n; i++) {
		y+=x1[i]*x2[i];
	}
	return y;	
}

inline Interval operator*(const Vector& x1, const IntervalVector& x2) {
	return x2*x1;
}

inline Interval operator*(const IntervalVector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x1.size()==x2.size());
	if (x1.is_empty()) return Interval::EMPTY_SET;
	Interval y(0);
	for (int i=0; i<n; i++) {
		y+=x1[i]*x2[i];
	}
	return y;	
}

inline Interval operator*(const IntervalVector& x1, const IntervalVector& x2) {
	const int n=x1.size();
	assert(x1.size()==x2.size());
	if (x1.is_empty() || x2.is_empty()) return Interval::EMPTY_SET;
	Interval y(0);
	for (int i=0; i<n; i++) {
		y+=x1[i]*x2[i];
	}
	return y;
}

inline Vector& operator+=(Vector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	for (int i=0; i<n; i++) {
		x1[i]+=x2[i];
	}
	return x1;	
}

inline IntervalVector& operator+=(IntervalVector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	if (x1.is_empty()) return x1;
	if (!x1.is_empty()) {
		for (int i=0; i<n; i++) {
			x1[i]+=x2[i];
		}
	}
	return x1;	
}

inline IntervalVector& operator+=(IntervalVector& x1, const IntervalVector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	if (!x1.is_empty()) {
		if (x2.is_empty()) { x1.set_empty(); }
		else {
			for (int i=0; i<n; i++) {
				x1[i]+=x2[i];
			}
		}
	}
	return x1;
}

inline Vector& operator-=(Vector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	for (int i=0; i<n; i++) {
		x1[i]-=x2[i];
	}
	return x1;	
}

inline IntervalVector& operator-=(IntervalVector& x1, const Vector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	if (!x1.is_empty()) {
		for (int i=0; i<n; i++) {
			x1[i]-=x2[i];
		}
	}
	return x1;	
}

inline IntervalVector& operator-=(IntervalVector& x1, const IntervalVector& x2) {
	const int n=x1.size();
	assert(x2.size()==x1.size());
	if (!x1.is_empty()) {
		if (x2.is_empty()) { x1.set_empty(); }
		else {
			for (int i=0; i<n; i++) {
				x1[i]-=x2[i];
			}
		}
	}
	return x1;
}


inline Vector operator*(double d, const Vector& x) {
	Vector _x(x);
	return _x*=d; 
}

inline IntervalVector operator*(double d, const IntervalVector& x) {
	IntervalVector _x(x);
	return _x*=d;
}

inline IntervalVector operator*(Interval& itv, const Vector& x) {
	IntervalVector _x(x);
	return _x*=itv;
}

inline IntervalVector operator*(Interval& itv, const IntervalVector& x) {
	IntervalVector _x(x);
	return _x*=itv;
}

inline Vector& operator*=(Vector& x, double d) {
	for (int i=0; i<x.size(); i++)
		x[i]*=d;
	return x;
}

inline IntervalVector& operator*=(IntervalVector& x, double d) {
	if (x.is_empty()) return x;
	for (int i=0; i<x.size(); i++)
		x[i]*=d;
	return x;
}

inline IntervalVector& operator*=(IntervalVector& x2, const Interval& x1) {
	if (x2.is_empty()) return x2;
	else if (x1.is_empty()) { x2.set_empty(); return x2; }
	
	for (int i=0; i<x2.size(); i++)
		x2[i]*=x1;
	return x2;
}

inline std::ostream& operator<<(std::ostream& os, const IntervalVector& x) {
	os << "(";
	for (int i=0; i<x.size(); i++)
		os << x[i] << (i<x.size()-1? " ; " : "");
	os << ")";
	return os;
}


} // end namespace

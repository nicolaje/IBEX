//============================================================================
//                                  I B E X                                   
// File        : ibex_SystemNormalize.cpp_
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : May 27, 2013
// Last Update : May 27, 2013
//============================================================================

#include "ibex_SystemFactory.h"

using std::pair;

namespace ibex {

namespace {


class SystemNormalize : public SystemFactory {

	public:

	SystemNormalize(const System& sys, double eps) {

		// do not initialize variables with sys.f.args
		// since f may be uninitialized (unconstrained problem)
		add_var(sys.args);

		if (sys.goal!=NULL) add_goal(*sys.goal);

		// note: sys.ctrs.size()<>sys.nb_ctr in general but
		// with NORMALIZE, they have to match (only scalar constraints).
		if(sys.ctrs.size()!=sys.nb_ctr) {
			not_implemented("normalization with vector equations");
		}
		for (int i=0; i<sys.ctrs.size(); i++) {

			if (sys.ctrs[i].op==EQ) {
				pair<const ExprNode*, const Interval*> p=sys.ctrs[i].is_thick_equality();
				const ExprNode *f_1;
				const ExprNode *f_2;
				if (p.first!=NULL) {
					f_1=&( ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, *p.first) - p.second->ub());
					f_2=&(-ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, *p.first) - (-p.second->lb()));
				} else {
					f_1=&( ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, sys.ctrs[i].f.expr()) - eps);
					f_2=&(-ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, sys.ctrs[i].f.expr()) - eps);
				}
				add_ctr(ExprCtr(*f_1,LEQ));
				cleanup(*f_1, false);
				add_ctr(ExprCtr(*f_2,LEQ));
				cleanup(*f_2, false);
			} else {

				const ExprNode* f_i=&ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, sys.ctrs[i].f.expr());

				switch (sys.ctrs[i].op) {
				case LT:
					ibex_warning("warning: strict inequality (<) replaced by inequality (<=).");
					break;
				case LEQ:
					break;
				case GT:
					ibex_warning("warning: strict inequality (>) replaced by inequality (>=).");
				case GEQ:
					f_i = & (- (*f_i)); // reverse the inequality
					break;
				default:
					assert(false);
					break;
				}

				add_ctr(ExprCtr(*f_i,LEQ));
				cleanup(*f_i, false);
			}


		}
	}
};

} // end anonymous namespace

} // end namespace ibex

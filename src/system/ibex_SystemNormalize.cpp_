//============================================================================
//                                  I B E X                                   
// File        : ibex_SystemNormalize.cpp_
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : May 27, 2013
// Last Update : May 27, 2013
//============================================================================

#include "ibex_SystemFactory.h"

using std::pair;

namespace ibex {

namespace {


class SystemNormalize : public SystemFactory {

	public:

	SystemNormalize(const System& sys) {

		// do not initialize variables with sys.f.args
		// since f may be uninitialized (unconstrained problem)
		add_var(sys.args);

		if (sys.goal!=NULL) add_goal(*sys.goal);

		// note: sys.ctrs.size()<>sys.nb_ctr in general but
		// with NORMALIZE, they actually match (only scalar constraints).
		for (int i=0; i<sys.ctrs.size(); i++) {

			if (sys.ctrs[i].op==EQ) {
				pair<const ExprNode*, const Interval*> p=sys.ctrs[i].is_thick_equality();

				if (p.first!=NULL) { //not_implemented("normalization with equality constraints");

					const ExprNode& f_1=ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, *p.first) - p.second->ub();
					add_ctr(ExprCtr(f_1,LEQ));
					cleanup(f_1, false);

					double toto=-p.second->lb();
					const ExprNode& f_2=(-ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, *p.first)) -toto;
					add_ctr(ExprCtr(f_2,LEQ));
					cleanup(f_2, false);

					continue;
				}
			}

			const ExprNode* f_i=&ExprCopy().copy(sys.ctrs[i].f.args(), sys.args, sys.ctrs[i].f.expr());

			CmpOp op=LEQ;
			switch (sys.ctrs[i].op) {
			case LT:
				ibex_warning("warning: strict inequality (<) replaced by inequality (<=).");
			case LEQ:
				break;
			case EQ:
				op=EQ;
				break;
			case GT:
				ibex_warning("warning: strict inequality (>) replaced by inequality (>=).");
			case GEQ:
				f_i = & (- (*f_i)); // reverse the inequality
				break;
			}

			add_ctr(ExprCtr(*f_i,op));

			cleanup(*f_i, false);
		}
	}
};

} // end anonymous namespace

} // end namespace ibex

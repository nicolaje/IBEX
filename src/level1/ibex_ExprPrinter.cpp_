/* ============================================================================
 * I B E X - Expression Printer
 * ============================================================================
 * Copyright   : Ecole des Mines de Nantes (FRANCE)
 * License     : This program can be distributed under the terms of the GNU LGPL.
 *               See the file COPYING.LESSER.
 *
 * Author(s)   : Gilles Chabert
 * Created     : Mar 24, 2012
 * ---------------------------------------------------------------------------- */

#include "ibex_FunctionVisitor.h"
#include <cassert>

namespace ibex {

namespace {

class ExprPrinter : public virtual FunctionVisitor {

public:
	std::ostream& os;

	/** Build an expression printer on a given output stream. */
	ExprPrinter(std::ostream& os) : os(os) { }

	virtual void visit(const ExprNode& e) {
		e.acceptVisitor(*this);
	}

	virtual void visit(const ExprIndex& e) {
		os << e.expr << "[" << e.index << "]";
	}

	virtual void visit(const ExprVector& e) {
		for (int i=0; i<e.size(); i++) {
			visit(e.get(i));
			if (i<e.size()-1) os << ",";
		}
		os << ")";
	}

	virtual void visit(const ExprSymbol& e) {
		os << e.name;
	}

	virtual void visit(const ExprConstant& e) {
		switch (e.type()) {
		case Dim::SCALAR : os << e.get_value(); break;
		case Dim::VECTOR : os << e.get_vector_value(); break;
		case Dim::MATRIX : os << e.get_matrix_value(); break;
		default: assert(false); break;
		}
	}

	virtual void visit(const ExprUnaryOp& e) {
		assert(false);
	}

	virtual void visit(const ExprBinaryOp& e) {
		assert(false);
	}

	virtual void visit(const ExprApply& a) {
		os << a.func.name << "(";
		for (int i=0; i<a.nb_args(); i++) {
			visit(*a.args[i]);
			if (i<a.nb_args()-1) os << ",";
		}
		os << ")";
	}

	virtual void visit(const ExprAdd& e) { os << "(" << e.left << "+" << e.right << ")"; }
	virtual void visit(const ExprMul& e) { os << "(" << e.left << "*" << e.right << ")"; }
	virtual void visit(const ExprSub& e) { os << "(" << e.left << "-" << e.right << ")"; }
	virtual void visit(const ExprDiv& e) { os << "(" << e.left << "/" << e.right << ")"; }

	virtual void visit(const ExprMax& e)   { os << "max("   << e.left << "," << e.right << ")"; }
	virtual void visit(const ExprMin& e)   { os << "min("   << e.left << "," << e.right << ")"; }
	virtual void visit(const ExprAtan2& e) { os << "atan2(" << e.left << "," << e.right << ")"; }

	virtual void visit(const ExprMinus& e) { os << "-("    << e.expr << ")"; }
	virtual void visit(const ExprSign& e)  { os << "sign(" << e.expr << ")"; }
	virtual void visit(const ExprAbs& e)   { os << "abs("  << e.expr << ")"; }
	virtual void visit(const ExprPower& e) { os << "(" << e.expr << ")^" << e.expon ; }
	virtual void visit(const ExprSqr& e)   {os << "sqr("   << e.expr << ")";}
	virtual void visit(const ExprSqrt& e)  {os << "sqrt("  << e.expr << ")";}
	virtual void visit(const ExprExp& e)   {os << "exp("   << e.expr << ")";}
	virtual void visit(const ExprLog& e)   {os << "log("   << e.expr << ")";}
	virtual void visit(const ExprCos& e)   {os << "cos("   << e.expr << ")";}
	virtual void visit(const ExprSin& e)   {os << "sin("   << e.expr << ")";}
	virtual void visit(const ExprTan& e)   {os << "tan("   << e.expr << ")";}
	virtual void visit(const ExprCosh& e)  {os << "cosh("  << e.expr << ")";}
	virtual void visit(const ExprSinh& e)  {os << "sinh("  << e.expr << ")";}
	virtual void visit(const ExprTanh& e)  {os << "tanh("  << e.expr << ")";}
	virtual void visit(const ExprAcos& e)  {os << "acos("  << e.expr << ")";}
	virtual void visit(const ExprAsin& e)  {os << "asin("  << e.expr << ")";}
	virtual void visit(const ExprAtan& e)  {os << "atan("  << e.expr << ")";}
	virtual void visit(const ExprAcosh& e) {os << "acosh(" << e.expr << ")";}
	virtual void visit(const ExprAsinh& e) {os << "asinh(" << e.expr << ")";}
	virtual void visit(const ExprAtanh& e) {os << "atanh(" << e.expr << ")";}
};

} // end anonymous namespace

} // end ibex namespace



//============================================================================
//                                  I B E X                                   
// File        : ibex_ExprCopy.cpp_
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Apr 9, 2012
// Last Update : Apr 9, 2012
//============================================================================

#include <stdlib.h>
#include "ibex_FunctionVisitor.h"
#include "ibex_Expr.h"

namespace ibex {

class ResetVisited : public FunctionVisitor {
public:
	ResetVisited(const ExprNode& e)   { visit(e); }
protected:
	void visit(const ExprNode& e)     { e.deco.visited=false; e.acceptVisitor(*this); }
	void visit(const ExprIndex& i)    { visit(i.expr); }
	void visit(const ExprSymbol& v)   { }
	void visit(const ExprConstant& c) { }
	void visit(const ExprNAryOp& e)   { for (int i=0; i<e.nb_args; i++) visit(e.arg(i)); }
	void visit(const ExprBinaryOp& b) { visit(b.left); visit(b.right); }
	void visit(const ExprUnaryOp& u)  {	visit(u.expr); }
};

class SizeofDAG : public FunctionVisitor {
public:
	/* for binary expressions (BinOpExpr). */
	SizeofDAG(const ExprNode& l, const ExprNode& r) : size(0) {
		l.reset_visited();
		r.reset_visited();
		visit(l);
		visit(r);
	}

	/* for n-ary expressions (Apply). */
	SizeofDAG(const ExprNode** args, int n) : size(0) {
		for (int i=0; i<n; i++) args[i]->reset_visited();
		for (int i=0; i<n; i++) visit(*args[i]);
	}

	int size;

private:
	 void visit(const ExprNode& e) {
		if (!e.deco.visited) {
			e.deco.visited=true;
			size++;
			e.acceptVisitor(*this);
		}
	}

	 void visit(const ExprIndex& e)    { visit(e.expr); }
	 void visit(const ExprSymbol& e)   { }
	 void visit(const ExprConstant& e) { }
	 void visit(const ExprNAryOp& e)   { for (int i=0; i<e.nb_args; i++) visit(e.arg(i)); }
	 void visit(const ExprBinaryOp& e) { visit(e.left); visit(e.right); }
	 void visit(const ExprUnaryOp& e)  { visit(e.expr); }
};

class ExprSubNodes : public FunctionVisitor {
	const ExprNode** subnodes;
	int j;

public:

	ExprSubNodes(const ExprNode& e) {
		subnodes = new const ExprNode*[e.size];
		e.reset_visited();
		j=0;
		visit(e);
	}

	/*
	 * \warning The result array must be freed by the caller
	 */
	const ExprNode** nodes() {
		return subnodes;
	}

protected:
	void visit(const ExprNode& e) {
		if (!e.deco.visited) {
			e.deco.visited=true;
			subnodes[j++]=&e;
			e.acceptVisitor(*this);
		}
	}

	void visit(const ExprIndex& i)    { visit(i.expr); }
	void visit(const ExprSymbol& v)   { }
	void visit(const ExprConstant& c) { }
	void visit(const ExprNAryOp& e)   { for (int i=0; i<e.nb_args; i++) visit(e.arg(i)); }
	void visit(const ExprBinaryOp& b) { visit(b.left); visit(b.right); }
	void visit(const ExprUnaryOp& u)  {	visit(u.expr); }
};

} // end namespace

//============================================================================
//                                  I B E e
// File        : ibex_ExprDiff.cpp
// Author      : Gilles Chabert
// Diffright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Feb 25, 2013
// Last Update : Feb 25, 2013
//============================================================================

#include "ibex_ExprDiff.h"
#include "ibex_ExprCopy.h"
#include "ibex_ExprSubNodes.h"
#include "ibex_Expr.h"

using namespace std;

namespace ibex {

#define ONE          ExprConstant::new_scalar(1.0)


const ExprVector& zeros(int n, bool in_row) {
	Array<const ExprNode> zeros(n);
	for (int i=0; i<n; i++) zeros.set_ref(i,ExprConstant::new_scalar(0));
	return ExprVector::new_(zeros,in_row);
}

const ExprVector& zeros(int m, int n) {
	Array<const ExprNode> _zeros(m);
	for (int i=0; i<m; i++) _zeros.set_ref(i,zeros(n,true));
	return ExprVector::new_(_zeros,false);
}

void ExprDiff::add_grad_expr(const ExprNode& node, const ExprNode& _expr_) {

	if (grad.found(node))
		grad[node]= & (*grad[node] +_expr_);
	else
		// not found means "zero"
		grad.insert(node, &_expr_);
}

const ExprNode& ExprDiff::diff(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y) {
	if (y.dim.is_scalar()) {
		return gradient(old_x,new_x,y);
	} else if (y.dim.is_vector()) {
		const ExprVector* vec=dynamic_cast<const ExprVector*>(&y);
		int m=y.dim.vec_size();
		Array<const ExprNode> a(m);
		for (int i=0; i<m; i++) { // y.dim.vec_size() == vec->nb_args()
			a.set_ref(i,gradient(old_x,new_x,vec->arg(i)));
		}
		return ExprVector::new_(a,false);
	} else {
		not_implemented("differentiation of matrix-valued functions");
		return y;
	}
}

const ExprNode& ExprDiff::gradient(const Array<const ExprSymbol>& old_x, const Array<const ExprSymbol>& new_x, const ExprNode& y) {

	grad.clean();
	leaves.clear();

	ExprSubNodes nodes(y);
	//cout << "y =" << y;
	int n=y.size;
	int nb_var=0;
	for (int i=0; i<old_x.size(); i++) {
		nb_var += old_x[i].dim.size();
	}

	add_grad_expr(nodes[0],ONE);

	// visit nodes in topological order
	for (int i=0; i<n; i++) {
		visit(nodes[i]);
	}

	Array<const ExprNode> dX(nb_var);

	{   // =============== set null derivative for missing variables ===================
		// note: we have to make the association with grad[old_x[i]] because this map is
		// cleared after.
		for (int i=0; i<old_x.size(); i++) {

			const ExprNode& v=old_x[i];

			if (grad.found(v)) continue;

			leaves.push_back(&v);

			// this symbol does not appear in the expression -> null derivative
			switch (v.dim.type()) {
			case Dim::SCALAR:
				grad.insert(v, &ExprConstant::new_scalar(0));
				break;
			case Dim::ROW_VECTOR:
			case Dim::COL_VECTOR:
				grad.insert(v, &zeros(v.dim.vec_size(), v.dim.type()==Dim::ROW_VECTOR));
				break;
			case Dim::MATRIX:
				grad.insert(v, &zeros(v.dim.dim2,v.dim.dim3));
				break;
			default:
				not_implemented("diff with matrix arrays");
				break;
			}
		}
	}

	{   // =============== build dX ===================
		int k=0;
		for (int i=0; i<old_x.size(); i++) {

			switch (old_x[i].dim.type()) {
			case Dim::SCALAR:
				dX.set_ref(k++,*grad[old_x[i]]);
				break;
			case Dim::ROW_VECTOR:
			case Dim::COL_VECTOR:
				{	const ExprVector& vec = * ((const ExprVector*) grad[old_x[i]]);
					for (int j=0; j<old_x[i].dim.vec_size(); j++)
						dX.set_ref(k++,vec.arg(j));
				}
			break;
			case Dim::MATRIX:
			    {
			    	const ExprVector& vec = * ((const ExprVector*) grad[old_x[i]]);
			    	for (int j2=0; j2<old_x[i].dim.dim2; j2++) {
			    		const ExprVector& vec2 = (const ExprVector&) vec.arg(j2);
			    		for (int j3=0; j3<old_x[i].dim.dim3; j3++)
			    			dX.set_ref(k++, vec.arg(j3));
			    	}
			    }
			    break;
			default:
				not_implemented("diff with matrix arrays");
				break;
			}
		}
		assert(k==nb_var);
	}

	const ExprNode& df=ExprVector::new_(dX,true);

	// Note: it is better to proceed in this way: (1) differentiate
	// and (2) copy the expression for two reasons
	// 1-we can eliminate the constant expressions such as (1*1)
	//   generated by the differentiation
	// 2-the "dead" branches corresponding to the partial derivative
	//   w.r.t. ExprConstant leaves will are deleted properly (if
	//   we had proceeded in the other way around, there would be
	//   memory leaks).

	const ExprNode& result=ExprCopy().copy(old_x,new_x,df,true);

	// ------------------------- CLEANUP -------------------------
	// cleanup(df,true); // don't! some nodes are shared with y

	// don't! some grad are references to nodes of y!
	//	for (int i=0; i<n; i++)
	//	  delete grad[*nodes[i]];

	// we build the vector of the partial derivatives
	// wrt all the leaves, including constants.
	Array<const ExprNode> _dAll(leaves.size());

	for (unsigned int i=0; i<leaves.size(); i++) {
		_dAll.set_ref(i,*grad[*leaves[i]]);
	}
	cout << "==================" << endl;

	// build the global DAG
	const ExprNode* dAll=&ExprVector::new_(_dAll,true);

	ExprSubNodes gnodes(*dAll);
	int k=dAll->size;
	for (int j=0; j<k; j++) {
		if (!nodes.found(gnodes[j])) { // if the node is not in the original expression
			//cout << "not found:" << *gnodes[j] << endl;
			delete &gnodes[j];      // delete it.
		}
	}

	delete &df;
	//cout << "   ---> grad:" << result << endl;
	return result;
}

void ExprDiff::visit(const ExprNode& e) {
	e.acceptVisitor(*this);
}

void ExprDiff::visit(const ExprIndex& i) {

	if (i.expr.dim.is_scalar()) { // => i.index==0
		add_grad_expr(i.expr, *grad[i]);
		return;
	}

	if (i.expr.dim.type()==Dim::MATRIX_ARRAY) {
		not_implemented("diff with matrix arrays");
	}

	int n = i.expr.dim.max_index()+1;

	// we will build a new vector from scratch
	Array<const ExprNode> new_comp(n);

	if (grad.found(i.expr)) {
		const ExprVector* old_g=(const ExprVector*) grad[i.expr];
		assert(old_g);
		for (int j=0; j<n; j++) {
			if (j!=i.index)
				// duplicate all other components
				new_comp.set_ref(j, old_g->arg(j));
			else {
				if (old_g->arg(i.index).is_zero()) {
					new_comp.set_ref(i.index, *(grad[i]));
					delete &old_g->arg(i.index);
				}
				else
					new_comp.set_ref(i.index, old_g->arg(i.index) + *(grad[i]));
			}
		}
		// do not call cleanup(*old_g) because subnodes are still used.
		delete old_g;
	} else {
		// not found means "zero"
		for (int j=0; j<n; j++) {
			if (j!=i.index)
				// duplicate all other components
				if (i.expr.dim.is_vector())
					new_comp.set_ref(j, ExprConstant::new_scalar(0));
				else
					new_comp.set_ref(j, zeros(i.expr.dim.dim3,false));
			else
				new_comp.set_ref(i.index, *(grad[i]));
		}
	}

	grad[i.expr] = & ExprVector::new_(new_comp, i.expr.dim.type()==Dim::ROW_VECTOR);
}

void ExprDiff::visit(const ExprSymbol& x) {
	leaves.push_back(&x);
}

void ExprDiff::visit(const ExprConstant& c) {
	leaves.push_back(&c);
}

// (useless so far)
void ExprDiff::visit(const ExprNAryOp& e) {
	assert(false);
}

void ExprDiff::visit(const ExprLeaf& e) {
	assert(false);
}

// (useless so far)
void ExprDiff::visit(const ExprBinaryOp& b) {
	assert(false);
}

// (useless so far)
void ExprDiff::visit(const ExprUnaryOp& u) {
	assert(false);
}


void ExprDiff::visit(const ExprVector& e) {

	for (int i=0; i<e.nb_args; i++) {
		add_grad_expr(e.arg(i), ((const ExprVector*) grad[e])->get(i));
	}
}

void ExprDiff::visit(const ExprApply& e) {

	//TODO
	not_implemented("diff with apply");
}

void ExprDiff::visit(const ExprAdd& e)   { add_grad_expr(e.left,  *grad[e]);
                                           add_grad_expr(e.right, *grad[e]); }
void ExprDiff::visit(const ExprMul& e)   { if (!e.dim.is_scalar()) not_implemented("diff with matrix/vector multiplication"); // TODO
                                           add_grad_expr(e.left,  e.right * (*grad[e]));
                                           add_grad_expr(e.right, e.left * (*grad[e])); }
void ExprDiff::visit(const ExprSub& e)   { add_grad_expr(e.left,  *grad[e]);
										   add_grad_expr(e.right, -*grad[e]); }
void ExprDiff::visit(const ExprDiv& e)   { add_grad_expr(e.left,  *grad[e]/e.right);
		                                   add_grad_expr(e.right, -(e.left*(*grad[e])/sqr(e.right))); }
void ExprDiff::visit(const ExprMax& e)   { not_implemented("diff with max");; }
void ExprDiff::visit(const ExprMin& e)   { not_implemented("diff with min"); }
void ExprDiff::visit(const ExprAtan2& e) { not_implemented("diff with atan2"); }


void ExprDiff::visit(const ExprPower& e) {
	add_grad_expr(e.expr,Interval(e.expon)*pow(e.expr,e.expon-1)*(*grad[e]));
}

void ExprDiff::visit(const ExprMinus& e) { add_grad_expr(e.expr, -*grad[e]); }
void ExprDiff::visit(const ExprTrans& e) { not_implemented("diff with transpose"); } //TODO
void ExprDiff::visit(const ExprSign& e)  { not_implemented("diff with sign"); }      //TODO
void ExprDiff::visit(const ExprAbs& e)   { not_implemented("diff with abs"); }       //TODO
void ExprDiff::visit(const ExprSqr& e)   { add_grad_expr(e.expr, (*grad[e])*Interval(2.0)*e.expr); }
void ExprDiff::visit(const ExprSqrt& e)  { add_grad_expr(e.expr, (*grad[e])*Interval(0.5)/sqrt(e.expr)); }
void ExprDiff::visit(const ExprExp& e)   { add_grad_expr(e.expr, (*grad[e])*exp(e.expr)); }
void ExprDiff::visit(const ExprLog& e)   { add_grad_expr(e.expr, (*grad[e])/e.expr ); }
void ExprDiff::visit(const ExprCos& e)   { add_grad_expr(e.expr,-(*grad[e])*sin(e.expr) ); }
void ExprDiff::visit(const ExprSin& e)   { add_grad_expr(e.expr, (*grad[e])*cos(e.expr) ); }
void ExprDiff::visit(const ExprTan& e)   { add_grad_expr(e.expr, (*grad[e])*(ONE+sqr(tan(e.expr)))); }
void ExprDiff::visit(const ExprCosh& e)  { add_grad_expr(e.expr, (*grad[e])*sinh(e.expr)); }
void ExprDiff::visit(const ExprSinh& e)  { add_grad_expr(e.expr, (*grad[e])*cosh(e.expr)); }
void ExprDiff::visit(const ExprTanh& e)  { add_grad_expr(e.expr, (*grad[e])*(ONE - sqr(tanh(e.expr)))); }
void ExprDiff::visit(const ExprAcos& e)  { add_grad_expr(e.expr,-(*grad[e])/sqrt(1.0-sqr(e.expr))); }
void ExprDiff::visit(const ExprAsin& e)  { add_grad_expr(e.expr, (*grad[e])/sqrt(1.0-sqr(e.expr))); }
void ExprDiff::visit(const ExprAtan& e)  { add_grad_expr(e.expr, (*grad[e])/(1.0+sqr(e.expr))); }
void ExprDiff::visit(const ExprAcosh& e) { add_grad_expr(e.expr, (*grad[e])/sqrt(sqr(e.expr) -1.0)); }
void ExprDiff::visit(const ExprAsinh& e) { add_grad_expr(e.expr, (*grad[e])/sqrt(1.0+sqr(e.expr))); }
void ExprDiff::visit(const ExprAtanh& e) { add_grad_expr(e.expr, (*grad[e])/(1.0-sqr(e.expr))); }

} // end namespace ibex

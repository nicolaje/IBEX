//============================================================================
//                                  I B E X                                   
// File        : ibex_ExprCopy.cpp_
// Author      : Gilles Chabert
// Copyright   : Ecole des Mines de Nantes (France)
// License     : See the LICENSE file
// Created     : Apr 9, 2012
// Last Update : Apr 9, 2012
//============================================================================

#include <stdlib.h>
#include <stdio.h>
#include "ibex_ExprVisitor.h"
#include "ibex_Expr.h"

namespace ibex {

namespace {

/* Write an index into a string, surrounded with brackets.
 * Up to 6 digits are allowed.
 * Return the length of the string. */
int index_2_string(char* buff, int index) {
	assert(index<1000000);
	int k=0;
	char number[6];
	buff[k++]='[';
	snprintf(number, 6, "%d", index);
	strcpy(&buff[k], number);
	k+=strlen(number);
	buff[k++]=']';
	return k;
}

char buff[1000];

/* Return the string corresponding to the subexpression
 * x[i] where x is a symbol name and i and index. */
const char* index_symbol_2_string(const char* symbol_name, int index1, int index2, int index3) {
	int k=0;
	strcpy(&buff[k], symbol_name);
	k+=strlen(symbol_name);

	if (index1!=-1) k+=index_2_string(&buff[k], index1);
	if (index2!=-1) k+=index_2_string(&buff[k], index2);
	if (index3!=-1) k+=index_2_string(&buff[k], index3);
	buff[k++]='\0';
	//cout << "debug name=" << buff << endl;
	return buff;
}

/*
class Unvectorize {

	vector<const ExprSymbol*> dest_symbols;
	Array<const ExprNode> peers;

	Unvectorize(Array<const ExprSymbol>& x) : peers(x.size()) {
		for (int i=0; i<x.size(); i++)
			visit(x[i]);
	}
protected:
	void visit(const ExprSymbol& x) {

		switch (x.type()) {
		case Dim::SCALAR:
			dest_symbols.push_back(&ExprSymbol::new_(x.name,x.dim));
			peers.set_ref(x.id,*dest_symbols.back());
			break;
		case Dim::ROW_VECTOR:
		case Dim::COL_VECTOR:
			// Example. Let x be a vector of 2 components.
			// The following node "v" is [x[0], x[1]]. It the src expression is:
			//           x->x[0]+x[1].
			// We will get in this case
			//          (x[0],x[1])->x[0]+x[1]
			// So v does not appear in the dest expression. But if the original expression is:
			//           x -> 0.1*x (scalar product)
			// we will get
			//          (x[0],x[1])->0.1*[x[0],x[1]]
			// and the right side of the multiplication points to v.
			const ExprNode* v[x.dim.vec_size()];
			for (int i=0; i<x.dim.vec_size(); i++) {
				dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,-1,-1,i)));
				v[i]=dest_symbols.back();
			}
			peers.set_ref(x.id,ExprVector::new_(v,x.dim.vec_size(),x.dim.type()==Dim::ROW_VECTOR));
			break;
		case Dim::MATRIX:
			const ExprNode* m[x.dim.dim2];
			for (int i=0; i<x.dim.dim2; i++) {
				const ExprNode* v[x.dim.dim3];
				for (int j=0; j<x.dim.dim3; j++) {
					dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,-1,i,j)));
					v[j]=dest_symbols.back();
				}
				m[i]= & ExprVector::new_(v,x.dim.dim3,true);
			}
			peers.set_ref(x.id,ExprVector::new_(m,x.dim.dim2,false));
			break;
		case Dim::MATRIX_ARRAY:
			const ExprNode* ma[x.dim.dim1];
			for (int i=0; i<x.dim.dim1; i++) {
				const ExprNode* m[x.dim.dim2];
				for (int j=0; j<x.dim.dim2; j++) {
					const ExprNode* v[x.dim.dim3];
					for (int k=0; k<x.dim.dim3; k++) {
						dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,i,j,k)));
						v[k]=dest_symbols.back();
					}
					m[j]= & ExprVector::new_(v,x.dim.dim3,true);
				}
				ma[i]= & ExprVector::new_(m,x.dim.dim2,false);
			}
			peers.set_ref(x.id, ExprVector::new_(ma,x.dim.dim1,true)); // notice: true or false does not matter here
			break;
		}
	}
};
*/


class ExprCopy : public ExprVisitor {
protected:
	Array<const ExprSymbol> new_x;
	const ExprNode* new_y;

public:

	/*
	 * \brief Set the expression of \a dest to x->f(x) where f(x) is the expression \a e.
	 *
	 */
	ExprCopy(const Array<const ExprSymbol>& x, const ExprNode& y) : new_x(x.size()) {
		// we have to proceed first the symbols in order to guarantee that
		// they appear in the same order in "dest". Indeed, if we add the symbols
		// as they appear in the expression the copy of a a function (x,y)->y+x
		// would yield (y,x)->y+x.
		y.reset_visited();
		for (int j=0; j<x.size(); j++) {
			new_x.set_ref(j,ExprSymbol::new_(x[j].name,x[j].dim));
			x[j].deco.tmp=&new_x[j];
		}
		visit(y);
		//cout << "new x=";
		//for (int j=0; j<new_x.size(); j++) cout << new_x[j].name << " ";
		//cout << endl;
		new_y=(const ExprNode*) y.deco.tmp;
		//cout << "new y=" << *new_y << endl;
	}

	Array<const ExprSymbol>& get_x() {
		return new_x;
	}

	const ExprNode& get_y() {
		return *new_y;
	}

protected:
	void visit(const ExprNode& e) {
		if (e.deco.tmp==NULL) {
			e.acceptVisitor(*this);
		}
	}

	void visit(const ExprIndex& i) {
		visit(i.expr);
		i.deco.tmp =& (*((const ExprNode*) i.expr.deco.tmp))[i.index];
	}

	void visit(const ExprSymbol& x) {
		// already done by the caller
	}

	void visit(const ExprConstant& c) {
		c.deco.tmp = &c.copy();
	}

	void visit(const ExprNAryOp& e) {
		e.acceptVisitor(*this);
	}

	void visit(const ExprBinaryOp& b) {
		b.acceptVisitor(*this);
	}

	void visit(const ExprUnaryOp& u) {
		u.acceptVisitor(*this);
	}

	void visit(const ExprVector& e) {
		for (int i=0; i<e.nb_args; i++)
			visit(e.arg(i));

		const ExprNode* args2[e.nb_args];
		for (int i=0; i<e.nb_args; i++)
			args2[i]=(const ExprNode*) e.arg(i).deco.tmp;

		e.deco.tmp=&ExprVector::new_(args2, e.nb_args, e.row_vector());
	}

	void visit(const ExprApply& e) {
		for (int i=0; i<e.nb_args; i++)
			visit(e.arg(i));

		const ExprNode* args2[e.nb_args];
		for (int i=0; i<e.nb_args; i++)
			args2[i]=(const ExprNode*) e.arg(i).deco.tmp;

		e.deco.tmp=&ExprApply::new_(e.func, args2);
	}

#define LEFT  (*((const ExprNode*) e.left.deco.tmp))
#define RIGHT (*((const ExprNode*) e.right.deco.tmp))
#define EXPR  (*((const ExprNode*) e.expr.deco.tmp))

	void visit(const ExprAdd& e)   { visit(e.left); visit(e.right); e.deco.tmp = &      (LEFT + RIGHT); }
	void visit(const ExprMul& e)   { visit(e.left); visit(e.right); e.deco.tmp = &      (LEFT * RIGHT); }
	void visit(const ExprSub& e)   { visit(e.left); visit(e.right); e.deco.tmp = &      (LEFT - RIGHT); }
	void visit(const ExprDiv& e)   { visit(e.left); visit(e.right); e.deco.tmp = &      (LEFT / RIGHT); }
	void visit(const ExprMax& e)   { visit(e.left); visit(e.right); e.deco.tmp = & max  (LEFT, RIGHT); }
	void visit(const ExprMin& e)   { visit(e.left); visit(e.right); e.deco.tmp = & min  (LEFT, RIGHT); }
	void visit(const ExprAtan2& e) { visit(e.left); visit(e.right); e.deco.tmp = & atan2(LEFT, RIGHT); }

	void visit(const ExprMinus& e) { visit(e.expr); e.deco.tmp = & -    (EXPR); }
	void visit(const ExprSign& e)  { visit(e.expr); e.deco.tmp = & sign (EXPR); }
	void visit(const ExprAbs& e)   { visit(e.expr); e.deco.tmp = & abs  (EXPR); }
	void visit(const ExprPower& e) { visit(e.expr); e.deco.tmp = & pow  (EXPR,e.expon); }
	void visit(const ExprSqr& e)   { visit(e.expr); e.deco.tmp = & sqr  (EXPR); }
	void visit(const ExprSqrt& e)  { visit(e.expr); e.deco.tmp = & sqrt (EXPR); }
	void visit(const ExprExp& e)   { visit(e.expr); e.deco.tmp = & exp  (EXPR); }
	void visit(const ExprLog& e)   { visit(e.expr); e.deco.tmp = & log  (EXPR); }
	void visit(const ExprCos& e)   { visit(e.expr); e.deco.tmp = & cos  (EXPR); }
	void visit(const ExprSin& e)   { visit(e.expr); e.deco.tmp = & sin  (EXPR); }
	void visit(const ExprTan& e)   { visit(e.expr); e.deco.tmp = & tan  (EXPR); }
	void visit(const ExprCosh& e)  { visit(e.expr); e.deco.tmp = & cosh (EXPR); }
	void visit(const ExprSinh& e)  { visit(e.expr); e.deco.tmp = & sinh (EXPR); }
	void visit(const ExprTanh& e)  { visit(e.expr); e.deco.tmp = & tanh (EXPR); }
	void visit(const ExprAcos& e)  { visit(e.expr); e.deco.tmp = & acos (EXPR); }
	void visit(const ExprAsin& e)  { visit(e.expr); e.deco.tmp = & asin (EXPR); }
	void visit(const ExprAtan& e)  { visit(e.expr); e.deco.tmp = & atan (EXPR); }
	void visit(const ExprAcosh& e) { visit(e.expr); e.deco.tmp = & acosh(EXPR); }
	void visit(const ExprAsinh& e) { visit(e.expr); e.deco.tmp = & asinh(EXPR); }
	void visit(const ExprAtanh& e) { visit(e.expr); e.deco.tmp = & atanh(EXPR); }
};

/*
 *
 * \brief Copy of a (sub)expression.
 *
 */
class ExprUnvectorize : public ExprVisitor {
protected:
	const ExprNode** peers;
	std::vector<const ExprSymbol*> dest_symbols;
	int root_id;
	bool unvectorize;

public:

	/*
	 * \brief Set the expression of \a dest to x->f(x) where f(x) is the expression \a e.
	 *
	 * \param unvectorize: if true, a vector symbol x in the original function (the
	 * one \a e belongs to) is replaced by scalar symbols "x[0]",...,"x[n]"
	 * in the destination function \a dest. Same for matrices & matrix arrays
	 */
	ExprUnvectorize(const ExprNode& e, Function& dest, bool unvectorize) : unvectorize(unvectorize) {

		const Function& src=*(e.deco.f);
		int n=src.nb_nodes();
		peers = new const ExprNode*[n]; // n is the max number of sub_nodes of "src"

		// peers[i] will stay NULL if src.context.node(i) is not a subnode of "src"
		for (int i=0; i<n; i++) peers[i]=NULL;

		// we have to proceed first the symbols in order to guarantee that
		// they appear in the same order in "dest". Indeed, if we add the symbols
		// as they appear in the expression the copy of a a function (x,y)->y+x
		// would yield (y,x)->y+x.
		for (int i=0; i<src.nb_symbols(); i++)
			visit(src.symbol(i));

		visit(e);

		root_id=e.id;
	}

	Array<const ExprSymbol> get_x() {
		return dest_symbols;
	}

	const ExprNode& get_y() {
		return *peers[root_id];
	}

	~ExprUnvectorize() {
		delete[] peers;
	}

protected:
	void visit(const ExprNode& e) {
		if (peers[e.id]==NULL) {
			e.acceptVisitor(*this);
		}
	}

	void visit(const ExprIndex& i) {
		visit(i.expr);
		if (unvectorize && i.indexed_symbol()) { // pick the corresponding symbol expr.
			const ExprVector& vexpr=(const ExprVector&) *peers[i.expr.id];
			peers[i.id]= & vexpr.get(i.index); // get "x[i]" as a symbol
		} else
			peers[i.id]=& (*peers[i.expr.id])[i.index];

	}

	void visit(const ExprSymbol& x) {

		if (!unvectorize || x.dim.is_scalar()) { // just duplicate the symbol
			dest_symbols.push_back(&ExprSymbol::new_(x.name,x.dim));
			peers[x.id]=dest_symbols.back();
			return;
		}

		switch (x.type()) {
		case Dim::SCALAR: // cannot happen
		case Dim::ROW_VECTOR:
		case Dim::COL_VECTOR:
			// Example. Let x be a vector of 2 components.
			// The following node "v" is [x[0], x[1]]. It the src expression is:
			//           x->x[0]+x[1].
			// We will get in this case
			//          (x[0],x[1])->x[0]+x[1]
			// So v does not appear in the dest expression. But if the original expression is:
			//           x -> 0.1*x (scalar product)
			// we will get
			//          (x[0],x[1])->0.1*[x[0],x[1]]
			// and the right side of the multiplication points to v.
			const ExprNode* v[x.dim.vec_size()];
			for (int i=0; i<x.dim.vec_size(); i++) {
				dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,-1,-1,i)));
				v[i]=dest_symbols.back();
			}
			peers[x.id]=&ExprVector::new_(v,x.dim.vec_size(),x.dim.type()==Dim::ROW_VECTOR);
			break;
		case Dim::MATRIX:
			const ExprNode* m[x.dim.dim2];
			for (int i=0; i<x.dim.dim2; i++) {
				const ExprNode* v[x.dim.dim3];
				for (int j=0; j<x.dim.dim3; j++) {
					dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,-1,i,j)));
					v[j]=dest_symbols.back();
				}
				m[i]= & ExprVector::new_(v,x.dim.dim3,true);
			}
			peers[x.id]=& ExprVector::new_(m,x.dim.dim2,false);
			break;
		case Dim::MATRIX_ARRAY:
			const ExprNode* ma[x.dim.dim1];
			for (int i=0; i<x.dim.dim1; i++) {
				const ExprNode* m[x.dim.dim2];
				for (int j=0; j<x.dim.dim2; j++) {
					const ExprNode* v[x.dim.dim3];
					for (int k=0; k<x.dim.dim3; k++) {
						dest_symbols.push_back(& ExprSymbol::new_(index_symbol_2_string(x.name,i,j,k)));
						v[k]=dest_symbols.back();
					}
					m[j]= & ExprVector::new_(v,x.dim.dim3,true);
				}
				ma[i]= & ExprVector::new_(m,x.dim.dim2,false);
			}
			peers[x.id]= & ExprVector::new_(ma,x.dim.dim1,true); // notice: true or false does not matter here
			//break;
		}
	}

	void visit(const ExprConstant& c) {
		switch(c.type()) {
		case Dim::SCALAR:     peers[c.id]=&ExprConstant::new_scalar(c.get_value()); break;
		case Dim::ROW_VECTOR: peers[c.id]=&ExprConstant::new_vector(c.get_vector_value(),true); break;
		case Dim::COL_VECTOR: peers[c.id]=&ExprConstant::new_vector(c.get_vector_value(),false); break;
		case Dim::MATRIX:     peers[c.id]=&ExprConstant::new_matrix(c.get_matrix_value()); break;
		case Dim::MATRIX_ARRAY: assert(false); break;
		}
	}

	void visit(const ExprNAryOp& e) {
		e.acceptVisitor(*this);
	}

	void visit(const ExprBinaryOp& b) {
		b.acceptVisitor(*this);
	}

	void visit(const ExprUnaryOp& u) {
		u.acceptVisitor(*this);
	}

	void visit(const ExprVector& e) {
		for (int i=0; i<e.nb_args; i++)
			visit(e.arg(i));

		const ExprNode* args2[e.nb_args];
		for (int i=0; i<e.nb_args; i++)
			args2[i]=peers[e.arg(i).id];

		peers[e.id]=&ExprVector::new_(args2, e.nb_args, e.row_vector());
	}

	void visit(const ExprApply& e) {
		for (int i=0; i<e.nb_args; i++)
			visit(e.arg(i));

		const ExprNode* args2[e.nb_args];
		for (int i=0; i<e.nb_args; i++)
			args2[i]=peers[e.arg(i).id];

		peers[e.id]=&ExprApply::new_(e.func, args2);
	}

	void visit(const ExprAdd& e)   { visit(e.left); visit(e.right); peers[e.id] = &      (*peers[e.left.id] + *peers[e.right.id]); }
	void visit(const ExprMul& e)   { visit(e.left); visit(e.right); peers[e.id] = &      (*peers[e.left.id] * *peers[e.right.id]); }
	void visit(const ExprSub& e)   { visit(e.left); visit(e.right); peers[e.id] = &      (*peers[e.left.id] - *peers[e.right.id]); }
	void visit(const ExprDiv& e)   { visit(e.left); visit(e.right); peers[e.id] = &      (*peers[e.left.id] / *peers[e.right.id]); }
	void visit(const ExprMax& e)   { visit(e.left); visit(e.right); peers[e.id] = & max  (*peers[e.left.id], *peers[e.right.id]); }
	void visit(const ExprMin& e)   { visit(e.left); visit(e.right); peers[e.id] = & min  (*peers[e.left.id], *peers[e.right.id]); }
	void visit(const ExprAtan2& e) { visit(e.left); visit(e.right); peers[e.id] = & atan2(*peers[e.left.id], *peers[e.right.id]); }

	void visit(const ExprMinus& e) { visit(e.expr); peers[e.id] = & -    (*peers[e.expr.id]); }
	void visit(const ExprSign& e)  { visit(e.expr); peers[e.id] = & sign (*peers[e.expr.id]); }
	void visit(const ExprAbs& e)   { visit(e.expr); peers[e.id] = & abs  (*peers[e.expr.id]); }
	void visit(const ExprPower& e) { visit(e.expr); peers[e.id] = & pow  (*peers[e.expr.id],e.expon); }
	void visit(const ExprSqr& e)   { visit(e.expr); peers[e.id] = & sqr  (*peers[e.expr.id]); }
	void visit(const ExprSqrt& e)  { visit(e.expr); peers[e.id] = & sqrt (*peers[e.expr.id]); }
	void visit(const ExprExp& e)   { visit(e.expr); peers[e.id] = & exp  (*peers[e.expr.id]); }
	void visit(const ExprLog& e)   { visit(e.expr); peers[e.id] = & log  (*peers[e.expr.id]); }
	void visit(const ExprCos& e)   { visit(e.expr); peers[e.id] = & cos  (*peers[e.expr.id]); }
	void visit(const ExprSin& e)   { visit(e.expr); peers[e.id] = & sin  (*peers[e.expr.id]); }
	void visit(const ExprTan& e)   { visit(e.expr); peers[e.id] = & tan  (*peers[e.expr.id]); }
	void visit(const ExprCosh& e)  { visit(e.expr); peers[e.id] = & cosh (*peers[e.expr.id]); }
	void visit(const ExprSinh& e)  { visit(e.expr); peers[e.id] = & sinh (*peers[e.expr.id]); }
	void visit(const ExprTanh& e)  { visit(e.expr); peers[e.id] = & tanh (*peers[e.expr.id]); }
	void visit(const ExprAcos& e)  { visit(e.expr); peers[e.id] = & acos (*peers[e.expr.id]); }
	void visit(const ExprAsin& e)  { visit(e.expr); peers[e.id] = & asin (*peers[e.expr.id]); }
	void visit(const ExprAtan& e)  { visit(e.expr); peers[e.id] = & atan (*peers[e.expr.id]); }
	void visit(const ExprAcosh& e) { visit(e.expr); peers[e.id] = & acosh(*peers[e.expr.id]); }
	void visit(const ExprAsinh& e) { visit(e.expr); peers[e.id] = & asinh(*peers[e.expr.id]); }
	void visit(const ExprAtanh& e) { visit(e.expr); peers[e.id] = & atanh(*peers[e.expr.id]); }
};

} // end anonymous namespace
} // end ibex namespace
